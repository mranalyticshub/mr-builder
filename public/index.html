<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>MR Analytics Hub â€“ Dashboard Builder</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <script src="https://cdn.jsdelivr.net/npm/vega@5" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6" defer></script>
  <style>
    :root {
      --bg: #f5f5f7;
      --surface: #ffffff;
      --ink: #111111;
      --muted: #6b7280;
      --line: #e5e7eb;
      --accent: #2563eb;
      --accent-soft: #eff6ff;
      --ok: #16a34a;
      --err: #b91c1c;
      --radius-lg: 14px;
      --radius-sm: 8px;
      --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.08);
    }

    * { box-sizing:border-box; }

    html, body {
      margin:0;
      padding:0;
      background: radial-gradient(circle at top left, #f9fafb 0, #eef2ff 40%, #f5f5f7 100%);
      color:var(--ink);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", Segoe UI, Roboto, sans-serif;
    }

    .wrap {
      max-width: 1320px;
      margin: 0 auto;
      padding: 24px 20px 40px;
    }

    h1 {
      margin:0 0 4px;
      font-size: 32px;
      letter-spacing: .02em;
    }

    h2 {
      margin:0 0 6px;
      font-size: 18px;
      letter-spacing:.02em;
    }

    .muted {
      color:var(--muted);
      font-size:13px;
    }

    .row {
      display:flex;
      align-items:center;
      gap:12px;
    }

    .sid-badge {
      background:rgba(15,23,42,0.03);
      border:1px solid rgba(148,163,184,0.5);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
    }

    .pill {
      padding:4px 10px;
      border-radius:999px;
      background:rgba(37,99,235,0.06);
      color:#1d4ed8;
      font-size:11px;
      font-weight:500;
    }

    .card {
      border-radius:var(--radius-lg);
      background:var(--surface);
      box-shadow:var(--shadow-soft);
      padding:16px 18px 18px;
      margin-top:16px;
      border:1px solid rgba(148,163,184,0.25);
    }

    .toolbar {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:8px;
    }

    button {
      appearance:none;
      background:var(--accent);
      color:#fff;
      border:0;
      padding:9px 14px;
      border-radius:999px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      box-shadow:0 10px 25px rgba(37,99,235,0.35);
      transition:transform .08s ease-out, box-shadow .08s ease-out, background .08s ease-out;
    }
    button:hover { transform:translateY(-1px); box-shadow:0 16px 40px rgba(37,99,235,0.4); }
    button:active { transform:translateY(0); box-shadow:0 10px 25px rgba(37,99,235,0.3); }
    button.secondary {
      background:#f9fafb;
      color:#111827;
      border:1px solid #e5e7eb;
      box-shadow:none;
    }
    button.ghost {
      background:transparent;
      color:#111827;
      border:1px dashed #d4d4d8;
      box-shadow:none;
    }
    button.chip {
      padding:6px 10px;
      font-size:12px;
      border-radius:999px;
      background:#f3f4ff;
      color:#4338ca;
      border:1px solid rgba(129,140,248,0.6);
      box-shadow:none;
    }
    button.chip[data-active="1"] {
      background:#4f46e5;
      color:#eef2ff;
      border-color:#4f46e5;
    }
    button[disabled] {
      opacity:.55;
      cursor:not-allowed;
      box-shadow:none;
      transform:none;
    }

    input[type="text"],
    input[type="email"],
    input[type="date"],
    select,
    textarea {
      width:100%;
      padding:9px 11px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#f9fafb;
      font-size:13px;
      outline:none;
      transition:border .1s ease-out, box-shadow .1s ease-out, background .1s ease-out;
    }
    input[type="date"] {
      padding-inline:12px;
    }
    textarea {
      border-radius:12px;
      min-height: 120px;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      resize:vertical;
    }
    input:focus,
    textarea:focus,
    select:focus {
      border-color:#4f46e5;
      box-shadow:0 0 0 1px rgba(79,70,229,0.5);
      background:#ffffff;
    }

    .hidden { display:none !important; }

    .err { color:var(--err); font-size:13px; }
    .ok { color:var(--ok); font-size:13px; }

    /* Field Map */
    .fm-wrap {
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
      background:#f9fafb;
    }
    .fm-head,
    .fm-row {
      display:grid;
      grid-template-columns: 220px 140px 220px 1fr;
      align-items:flex-start;
      font-size:12px;
    }
    .fm-head {
      background:#f3f4ff;
      border-bottom:1px solid var(--line);
      font-weight:600;
    }
    .fm-head div,
    .fm-row div {
      padding:8px 10px;
      border-right:1px solid var(--line);
    }
    .fm-head div:last-child,
    .fm-row div:last-child {
      border-right:0;
    }
    .fm-body {
      max-height: 320px;
      overflow:auto;
      background:#fff;
    }
    .fm-row {
      border-bottom:1px solid var(--line);
    }
    .fm-row:nth-child(even) {
      background:#f9fafb;
    }
    .fm-edit {
      outline:none;
      border-radius:6px;
      min-height:24px;
    }
    .fm-edit:focus {
      box-shadow: inset 0 0 0 1px #93c5fd;
      background:#eff6ff;
    }

    /* Preview grid */
    #previewToolbar {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      margin:8px 0 12px;
    }

    #previewPanel {
      border-radius:20px;
      background:radial-gradient(circle at top left, #ffffff, #f3f4ff 40%, #ffffff 90%);
      padding:14px 14px 10px;
      border:1px solid rgba(148,163,184,0.4);
      box-shadow:var(--shadow-soft);
    }

    #previewCanvas {
      position:relative;
      min-height: 520px;
      height: calc(100vh - 260px);
      max-height: 900px;
      min-height: 520px;
      background:
        linear-gradient(135deg, rgba(248,250,252,1), rgba(241,245,249,1));
      overflow:hidden;
    }

    .tile {
      position:absolute;
      border-radius:14px;
      background:#ffffff;
      display:flex;
      flex-direction:column;
      box-shadow:0 10px 25px rgba(15,23,42,0.06);
      border:1px solid rgba(148,163,184,0.18);
      overflow:hidden;
    }
    .tile .t-h {
      font-weight:600;
      padding:8px 12px 6px;
      border-bottom:1px solid #eef2ff;
      cursor:move;
      user-select:none;
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:13px;
      background:#f9fafb;
    }
    .tile .t-h span.muted {
      font-size:11px;
      color:#9ca3af;
    }
    .tile .t-b {
      padding:10px 12px 12px;
      color:#111827;
      font-size:12px;
      flex:1;
      overflow:hidden;
      position:relative;
      background:#ffffff;
    }

    .kpi {
      font-size:32px;
      font-weight:800;
      letter-spacing:.03em;
      margin-bottom:4px;
    }
    .kpi-label {
      font-size:12px;
      color:#6b7280;
      margin-bottom:6px;
    }
    .kpi-delta {
      margin-top:2px;
      font-size:11px;
      font-weight:600;
      color:#16a34a;
      display:flex;
      align-items:center;
      gap:4px;
    }
    .kpi-delta.neg { color:#b91c1c; }


    .tooltip {
      position:absolute;
      pointer-events:none;
      background:#020617;
      color:#f9fafb;
      font-size:11px;
      padding:4px 7px;
      border-radius:6px;
      transform:translate(-50%,-120%);
      white-space:nowrap;
      display:none;
      box-shadow:0 10px 25px rgba(15,23,42,0.4);
    }

    .preview-empty {
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#9ca3af;
      font-size:14px;
      background:repeating-linear-gradient(
          45deg,
          #f9fafb,
          #f9fafb 12px,
          #eef2ff 12px,
          #eef2ff 24px
      );
    }

    .tablewrap {
      overflow:auto;
      height:100%;
      border-radius:10px;
      border:1px solid #e5e7eb;
      background:#f9fafb;
    }
    .tablewrap table {
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    .tablewrap th,
    .tablewrap td {
      border-bottom:1px solid #e5e7eb;
      padding:6px 8px;
      text-align:left;
    }
    .tablewrap th {
      background:#f3f4ff;
      font-weight:600;
    }
    .tablewrap tr:nth-child(even) td {
      background:#f9fafb;
    }

    .handle {
      position:absolute;
      width:14px;
      height:14px;
      right:4px;
      bottom:4px;
      cursor:nwse-resize;
      background:
        linear-gradient(135deg, transparent 0, transparent 45%, #cbd5f5 45%, #cbd5f5 55%, transparent 55%, transparent 100%);
      border-radius:4px;
      opacity:0.7;
    }

    .promptbar {
      display:flex;
      gap:8px;
      align-items:flex-start;
      margin-top:16px;
    }
    .promptbar textarea {
      min-height: 70px;
    }

    .badge {
      padding:2px 6px;
      border-radius:999px;
      background:#fee2e2;
      color:#b91c1c;
      font-size:10px;
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:.08em;
    }

    .date-group {
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
    }

    .tile .t-b.chart-body{
      padding: 6px 8px 8px;   /* tighter than default */
    }

    .tile .t-b.chart-body .chart{
      height: 100%;
      width: 100%;
      display: flex;
    }

    .tile .t-b.chart-body .chart svg{
      width: 100%;
      height: 100%;
      display: block;
    }

    .chart > .vega-embed,
    .chart > .vega-embed > .vega-actions,
    .chart > .vega-embed > details,
    .chart canvas,
    .chart svg {
      width: 100% !important;
      height: 100% !important;
    }

    .chart > .vega-embed { display:block; }
    .chart > .vega-embed details { display:none; } /* belt & braces */

    .msg.warn {
      background: #fff7ed;
      border-left: 4px solid #f59e0b;

/* ========== CHAT INTERFACE STYLES ========== */
.chat-container {
  margin-top: 20px;
  border-radius: var(--radius-lg);
  background: var(--surface);
  box-shadow: var(--shadow-soft);
  border: 1px solid rgba(148,163,184,0.25);
  overflow: hidden;
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}

.chat-header {
  padding: 12px 16px;
  background: linear-gradient(135deg, #690697 0%, #9d4edd 100%);
  color: white;
  font-weight: 600;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.chat-messages {
  max-height: 400px;
  min-height: 120px;
  overflow-y: auto;
  padding: 1em;
  display: flex;
  flex-direction: column;
  gap: 0.3em;
  background: #f9f9f9;
}

.chat-messages:empty::before {
  content: "AI responses will appear here...";
  color: var(--muted);
  font-size: 13px;
  font-style: italic;
  text-align: center;
  display: block;
  padding: 40px 20px;
}

.chat-message {
  display: flex;
  flex-direction: column;
  animation: slideIn 0.3s ease-out;
  margin: 0.3em 0;
}

@keyframes slideIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.chat-bubble {
  max-width: 75%;
  padding: 0.5em 1em;
  border-radius: 12px;
  line-height: 1.5;
  font-size: 13px;
  word-wrap: break-word;
  white-space: pre-wrap;
}

.chat-message-user {
  align-items: flex-end;
}

.chat-message-user .chat-bubble {
  background: #690697;
  color: white;
  align-self: flex-end;
  border-bottom-right-radius: 4px;
  box-shadow: 0 4px 12px rgba(105, 6, 151, 0.25);
}

.chat-message-ai {
  align-items: flex-start;
}

.chat-message-ai .chat-bubble {
  background: #e2e2e2;
  color: black;
  align-self: flex-start;
  border-bottom-left-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.chat-bubble-label {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 4px;
  opacity: 0.7;
}

.chat-message-user .chat-bubble-label {
  color: #690697;
  align-self: flex-end;
}

.chat-message-ai .chat-bubble-label {
  color: #690697;
  align-self: flex-start;
}

.chat-input-area {
  padding: 12px;
  background: #f9f9f9;
  border-top: 1px solid var(--line);
  display: flex;
  gap: 8px;
}

.chat-input-area textarea {
  flex: 1;
  min-height: 60px;
  resize: vertical;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid #ccc;
  background: white;
  font-size: 13px;
  font-family: inherit;
}

.chat-input-area textarea:focus {
  border-color: #690697;
  box-shadow: 0 0 0 2px rgba(105, 6, 151, 0.1);
  outline: none;
}

.chat-input-area button {
  align-self: flex-end;
  white-space: nowrap;
  padding: 0.5em 1.5em;
  font-size: 1em;
  background-color: #C45AFF;
  color: white;
  border: 3px solid #D892FF;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.chat-input-area button:hover {
  background-color: #D892FF;
  transform: scale(1.05);
}

.chat-input-area button:active {
  background-color: #C45AFF;
  transform: scale(1);
}

    }

    body.dark {
  --bg:#0b1220;
  --surface:#0f172a;
  --ink:#e5e7eb;
  --muted:#94a3b8;
  --line:#1f2937;
}

  </style>
</head>
<body>
<div class="wrap">
  <div class="row" style="margin-bottom:6px">
    <div style="flex:1">
      <h1>Dashboard Builder</h1>
      <div class="muted">Upload your data, answer a few questions, and let the assistant design the first version.</div>
    </div>
    <div class="row">
      <span class="muted">Session</span>
      <span id="sidBadge" class="sid-badge">â€“</span>
      <button id="newSession" class="secondary" type="button">New session</button>
    </div>
  </div>

  <!-- STEP 1 -->
  <div class="card" id="stepA">
    <div class="row" style="justify-content:space-between;align-items:flex-end">
      <div>
        <h2>1) Describe your business & upload a sample</h2>
        <div class="muted">Tell the assistant what you care about (channels, products, regions, goals).</div>
      </div>
      <span class="pill">Start here</span>
    </div>
    <textarea id="prompt" placeholder="E.g. We&#39;re an online sportswear retailer. I care about revenue, profit, orders, returns, and new vs existing customers by marketing channel."></textarea>
    <div class="toolbar">
      <input id="file" type="file" accept=".csv,.xlsx"/>
      <button id="start" type="button">Profile dataset</button>
      <span id="aMsg" class="muted"></span>
    </div>
  </div>

  <!-- STEP 2 -->
  <div class="card hidden" id="stepB">
    <h2>2) Field Map</h2>
    <div class="muted">Detected <span id="fCount">0</span> fields Â· <span id="qCount">0</span> clarifying questions.</div>
    <div class="fm-wrap" style="margin-top:10px">
      <div class="fm-head">
        <div>field</div><div>dtype</div><div>allowed</div><div>description</div>
      </div>
      <div id="fmBody" class="fm-body"></div>
    </div>
    <div style="margin-top:10px">
      <span id="bMsg" class="muted"></span>
    </div>
  </div>

  <!-- STEP 3 -->
  <div class="card hidden" id="stepC">
    <h2>3) Questions</h2>
    <div class="muted" style="margin-bottom:10px">These refine how the dashboard thinks about your data and time-grain.</div>
    <div id="qWrap"></div>
    <div style="margin-top:10px; display:flex; gap:10px; align-items:center">
      <button id="genDesign" type="button">Generate dashboard</button>
      <span id="cMsg" class="muted"></span>
    </div>
  </div>

  <!-- STEP 4 -->
  <div class="card hidden" id="stepD">
    <div class="row" style="justify-content:space-between;align-items:flex-end;margin-bottom:6px">
      <h2>4) Design & Preview</h2>
      <span class="muted">Drag tiles, resize, and tweak the design. Date filters and prompts update everything.</span>
    </div>

    <div id="previewToolbar">
      <div class="date-group">
        <button class="secondary" type="button" style="padding:7px 11px;font-size:12px" disabled>Filters</button>
        <span class="muted" style="font-size:12px">Start</span>
        <input id="filterStart" type="date"/>
        <span class="muted" style="font-size:12px">End</span>
        <input id="filterEnd" type="date"/>
        <button id="applyFilters" class="secondary" type="button">Apply</button>
        <button id="clearFilters" class="ghost" type="button">Clear filters</button>
      </div>
      <div class="date-group">
        <button class="chip" type="button" id="btnYTD">YTD</button>
        <button class="chip" type="button" id="btnLastYear">Last year</button>
        <button class="chip" type="button" id="btnThisMonth">This month</button>
        <button class="chip" type="button" id="btnLastMonth">Last month</button>
      </div>
      <div style="flex:1"></div>
      <button id="saveLayout" class="ghost" type="button" title="Persist current tile positions">Save layout</button>
      <button id="exportPdf" class="secondary" type="button" title="Print to PDF">Export PDF</button>
      <span id="dMsg" class="muted"></span>
    </div>

    <div id="previewPanel">
      <div id="previewCanvas"></div>
    </div>
    <div class="muted" style="margin-top:8px">Click chart elements to filter (coming soon). Drag/resize tiles to customise layout.</div>

    <!-- Chat Interface -->
    <div class="chat-container">
      <div class="chat-header">
        AI Dashboard Assistant
      </div>
      <div class="chat-messages" id="chatMessages">
        <!-- Messages will be dynamically added here -->
      </div>
      <div class="chat-input-area">
        <textarea id="changeText" placeholder="Describe the changes you want... (e.g., 'change the bar chart to a pie chart')"></textarea>
        <button id="applyChange" type="button">Send</button>
      </div>
    </div>
  </div>
</div>

<script>
const ORCH = "https://mr-orchestrator-585407302606.europe-west2.run.app";

const $ = (id) => document.getElementById(id);
function setMsg(id, text, cls="muted"){ const el=$(id); if(!el) return; el.className=cls; el.textContent = text||""; }
function show(id, flag){ $(id).classList.toggle("hidden", !flag); }
function setBusy(btn, on, label="Workingâ€¦"){
  if(!btn) return;
  btn.disabled = !!on;
  if(on){
    btn.dataset._t = btn.textContent;
    btn.textContent = label;
  } else if(btn.dataset._t){
    btn.textContent = btn.dataset._t;
    delete btn.dataset._t;
  }
}
function readQuery(k){ const p = new URLSearchParams(location.search); return p.get(k); }
function cookieGet(name){ return (`; ${document.cookie}`).split(`; ${name}=`).pop().split(';')[0] || ""; }
function cookieSet(name, value){ document.cookie = `${name}=${value}; Max-Age=3600; Path=/; SameSite=None; Secure`; }
function cookieDel(name){ document.cookie = `${name}=; Max-Age=0; Path=/; SameSite=None; Secure`; }

let sid = null;
let schemaFields = [];
let questions = [];
let answers = {};
let dsl = null;
let currentFilters = []; // reserved for future cross-filter support
let localLayout = {};   // tileId -> {x,y,w,h}

/* ------- palette helper (reads dsl.theme.palette) ------- */
function getPalette(){
  const def = ["#6366f1","#f97316","#10b981","#ec4899","#8b5cf6","#06b6d4","#facc15"];
  try{
    const pal = dsl?.theme?.palette;
    if(Array.isArray(pal) && pal.length) return pal;
  }catch(e){}
  return def;
}
function getCurrency(){ return dsl?.theme?.currency || "Â£"; }

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function seriesToRows(labels, values){
  const rows = [];
  for(let i=0;i<Math.max(labels?.length||0, values?.length||0);i++){
    rows.push({ label: String(labels?.[i] ?? ""), value: Number(values?.[i] ?? 0) });
  }
  return rows;
}

function vegaBaseConfig(){
  return {
    background: null,
    padding: 2,
    view: { stroke: null },
    axis: {
      labelFont: "system-ui",
      titleFont: "system-ui",
      labelFontSize: 11,
      titleFontSize: 11,
      gridColor: "#e5e7eb",
      tickColor: "#d1d5db",
      domainColor: "#d1d5db",
      labelColor: "#6b7280",
      titleColor: "#6b7280",
      tickCount: 5
    },
    legend: {
      labelFont: "system-ui",
      titleFont: "system-ui",
      labelFontSize: 11,
      titleFontSize: 11,
      labelColor: "#6b7280",
      titleColor: "#6b7280"
    }
  };
}

/**
 * Build a Vega-Lite spec from your existing d.series payload.
 * Uses t.type to pick bar/line/pie.
 */
function getAxisConfig(t){
  const rot = Number(t?.axis?.x?.rotate ?? 0);
  const angle = (rot === 90 ? 90 : rot === 45 ? 45 : rot === -45 ? -45 : 0);
  return {
    xLabelAngle: angle,
    // when rotated, reduce tick density a bit
    xTickCount: angle ? 4 : 6
  };
}

function specFromSeriesTile(t, d){
  const labels = d.series?.labels || [];
  const values = d.series?.values || [];
  const rows = seriesToRows(labels, values);

  const xLabel = d.series?.x_label || "";
  let yLabel = d.series?.y_label || "";
  if(/amount|revenue|sales|profit|turnover/i.test(yLabel)){
    yLabel = `${yLabel} (${getCurrency()})`;
  }

  const typ = String(t.type || "").toLowerCase();
  const ax = getAxisConfig(t);
  // Base
  const common = {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    data: { values: rows },
    width: "container",
    height: "container",
    config: vegaBaseConfig()
  };

  if(typ === "pie"){
    return {
      ...common,
      mark: { type: "arc", innerRadius: 40 },
      encoding: {
        theta: { field: "value", type: "quantitative" },
        color: { field: "label", type: "nominal", legend: { title: null } },
        tooltip: [
          { field: "label", type: "nominal" },
          { field: "value", type: "quantitative" }
        ]
      }
    };
  }

  if(typ === "line"){
    return {
      ...common,
      mark: { type: "line", point: { filled: true, size: 40 } },
      encoding: {
        x: { field: "label", type: "ordinal", axis: { title: xLabel, labelAngle: ax.xLabelAngle, tickCount: ax.xTickCount } },
        y: { field: "value", type: "quantitative", axis: { title: yLabel, tickCount: 5 } },
        tooltip: [
          { field: "label", type: "nominal" },
          { field: "value", type: "quantitative" }
        ]
      }
    };
  }

  // default = bar
  return {
    ...common,
    mark: { type: "bar", cornerRadiusEnd: 4 },
    encoding: {
      x: { field: "label", type: "ordinal", axis: { title: xLabel, labelAngle: ax.xLabelAngle, tickCount: ax.xTickCount } },
      y: { field: "value", type: "quantitative", axis: { title: yLabel, tickCount: 5 } },
      tooltip: [
        { field: "label", type: "nominal" },
        { field: "value", type: "quantitative" }
      ]
    }
  };
}

function specFromComboTile(t, d){
  const combo = d.combo || {};
  const labels = combo.labels || [];
  const xLabel = combo.x_label || "";
  const series = Array.isArray(combo.series) ? combo.series : [];

  if(!labels.length || !series.length){
    return specFromSeriesTile(t, d);
  }

  // Build row records with fields v0..vN
  const rows = labels.map((lb, i) => {
    const r = { label: String(lb ?? "") };
    series.forEach((s, k) => { r["v"+k] = Number((s.values||[])[i] ?? 0); });
    return r;
  });

  // Get palette
  const palette = getPalette();
  
  // Determine if we need dual axis (check if series specify different axes or have different mark types)
  const needsDualAxis = series.length === 2 && 
    ((series[0].axis || "left").toLowerCase() !== (series[1].axis || "left").toLowerCase() ||
     (series[0].mark || "line") !== (series[1].mark || "line"));
  
  const layers = series.map((s, k) => {
    const mark = (s.mark || "line").toLowerCase();
    const axis = needsDualAxis && k === 1 ? "right" : "left";
    const title = s.title || `Series ${k+1}`;
    const color = palette[k % palette.length];

    // Different mark types - make visually distinct
    const mk = (mark === "bar")
      ? { type: "bar", cornerRadiusEnd: 4, opacity: 0.75 }
      : { type: "line", point: { filled: true, size: 80 }, strokeWidth: 3 };

    return {
      mark: mk,
      encoding: {
        x: { 
          field: "label", 
          type: "ordinal", 
          axis: { 
            title: k === 0 ? xLabel : "", 
            labelAngle: 0, 
            tickCount: 6 
          } 
        },
        y: { 
          field: "v" + k, 
          type: "quantitative", 
          axis: needsDualAxis ? { 
            title: title, 
            orient: axis, 
            tickCount: 5,
            titleColor: color,
            titleFontWeight: "bold",
            titleFontSize: 12,
            labelColor: color,
            labelFontWeight: "bold",
            grid: k === 0,
            gridOpacity: 0.2
          } : {
            title: k === 0 ? "Value (Â£)" : "",
            orient: "left",
            tickCount: 5,
            grid: k === 0,
            gridOpacity: 0.2
          },
          scale: needsDualAxis ? { zero: false } : undefined
        },
        color: {
          datum: title,
          scale: { 
            domain: series.map(s => s.title || `Series ${series.indexOf(s)+1}`),
            range: series.map((s,i) => palette[i % palette.length])
          },
          legend: {
            title: null,
            orient: "top",
            direction: "horizontal",
            labelFontSize: 11,
            symbolSize: 100,
            symbolStrokeWidth: 2
          }
        },
        tooltip: [
          { field: "label", type: "nominal", title: xLabel },
          { field: "v" + k, type: "quantitative", title: title, format: ",.0f" }
        ]
      }
    };
  });

  return {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    width: "container",
    height: "container",
    config: vegaBaseConfig(),
    data: { values: rows },
    resolve: needsDualAxis ? { scale: { y: "independent" } } : undefined,
    layer: layers
  };
}

function normType(t){
  return String(t || "")
    .toLowerCase()
    .trim()
    .replace(/\s+/g, "_")
    .replace(/[()]/g, "");
}

function isChartType(type){
  const tt = normType(type);
  return new Set([
    "bar","line","pie","combo",
    "scatter","bubble",
    "stacked_bar","multi_series_bar","multi_series_line",
    "histogram","area","stacked_area",
    "heatmap","boxplot",
    "waterfall","gauge"
  ]).has(tt);
}

// ---------- payload normalisers ----------

// Existing: {series:{labels,values}} -> rows [{label,value}]
function seriesToRows(labels, values){
  const rows = [];
  for(let i=0;i<Math.max(labels?.length||0, values?.length||0);i++){
    rows.push({ label: String(labels?.[i] ?? ""), value: Number(values?.[i] ?? 0) });
  }
  return rows;
}

// Multi-series payload:
// d.multi_series = { labels:[...], series:[{name, values:[...]}] }
// -> long rows [{label, series, value}]
function multiSeriesToRows(ms){
  const labels = ms?.labels || [];
  const series = Array.isArray(ms?.series) ? ms.series : [];
  const rows = [];
  series.forEach(s => {
    const name = String(s?.name ?? s?.title ?? "Series");
    const vals = Array.isArray(s?.values) ? s.values : [];
    labels.forEach((lb, i) => {
      rows.push({ label: String(lb ?? ""), series: name, value: Number(vals[i] ?? 0) });
    });
  });
  return rows;
}

// Stacked payload:
// d.stacked = { labels:[...], series:[{name, values:[...]}] }
// -> long rows same as multi series (stacked uses series as color)
function stackedToRows(st){
  return multiSeriesToRows(st);
}

// Scatter payload:
// d.scatter = { points:[{x,y, label?, series?}] }
function scatterToRows(sc){
  const pts = Array.isArray(sc?.points) ? sc.points : [];
  return pts.map(p => ({
    x: Number(p?.x ?? 0),
    y: Number(p?.y ?? 0),
    label: p?.label != null ? String(p.label) : "",
    series: p?.series != null ? String(p.series) : ""
  }));
}

// Bubble payload:
// d.bubble = { points:[{x,y,size,label?,series?}] }
function bubbleToRows(bb){
  const pts = Array.isArray(bb?.points) ? bb.points : [];
  return pts.map(p => ({
    x: Number(p?.x ?? 0),
    y: Number(p?.y ?? 0),
    size: Number(p?.size ?? 0),
    label: p?.label != null ? String(p.label) : "",
    series: p?.series != null ? String(p.series) : ""
  }));
}

// Heatmap payload:
// d.heatmap = { rows:[{x,y,value}] }
function heatmapToRows(hm){
  const rows = Array.isArray(hm?.rows) ? hm.rows : [];
  return rows.map(r => ({ x: String(r?.x ?? ""), y: String(r?.y ?? ""), value: Number(r?.value ?? 0) }));
}

// Boxplot payload:
// d.boxplot = { rows:[{category,value}] }  (raw points; Vega will compute boxes)
function boxplotToRows(bp){
  const rows = Array.isArray(bp?.rows) ? bp.rows : [];
  return rows.map(r => ({ category: String(r?.category ?? ""), value: Number(r?.value ?? 0) }));
}

// Waterfall payload:
// d.waterfall = { steps:[{label, value, kind:'start'|'delta'|'end'}] }
// value for delta is +/-, start/end are absolute
function waterfallToRows(wf){
  const steps = Array.isArray(wf?.steps) ? wf.steps : [];
  return steps.map(s => ({
    label: String(s?.label ?? ""),
    value: Number(s?.value ?? 0),
    kind: String(s?.kind ?? "delta") // start|delta|end
  }));
}

// Gauge payload:
// d.gauge = { value, min?, max?, label? }
function gaugeToRows(g){
  const v = Number(g?.value ?? 0);
  const min = Number(g?.min ?? 0);
  const max = Number(g?.max ?? 100);
  const clamped = Math.max(min, Math.min(v, max));
  const pct = (max === min) ? 0 : ((clamped - min) / (max - min)) * 100;
  return [{ value: clamped, min, max, pct }];
}

// Histogram payload options:
// (A) d.histogram.values = [numbers...] (preferred; Vega bins)
// (B) d.series.values already counts per label (fallback)
function histogramValues(d){
  const vals = d?.histogram?.values;
  if(Array.isArray(vals) && vals.length) return vals.map(x => Number(x)).filter(x => Number.isFinite(x));
  return null;
}

// ---------- SPEC BUILDERS ----------

function specBase(values){
  return {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    data: { values },
    width: "container",
    height: "container",
    config: vegaBaseConfig()
  };
}

// keep your existing ones
// - specFromSeriesTile(t,d)
// - specFromComboTile(t,d)

function specScatter(t, d){
  const sc = d.scatter || d;
  const rows = scatterToRows(sc);
  const xTitle = sc?.x_label || "X";
  const yTitle = sc?.y_label || "Y";
  const hasSeries = rows.some(r => r.series);

  return {
    ...specBase(rows),
    mark: { type: "point", filled: true, size: 60 },
    encoding: {
      x: { field:"x", type:"quantitative", axis:{ title:xTitle } },
      y: { field:"y", type:"quantitative", axis:{ title:yTitle } },
      color: hasSeries ? { field:"series", type:"nominal", legend:{ title:null } } : undefined,
      tooltip: [
        { field:"x", type:"quantitative", title:xTitle },
        { field:"y", type:"quantitative", title:yTitle },
        ...(hasSeries ? [{ field:"series", type:"nominal" }] : []),
        { field:"label", type:"nominal" }
      ].filter(Boolean)
    }
  };
}

function specBubble(t, d){
  const bb = d.bubble || d;
  const rows = bubbleToRows(bb);
  const xTitle = bb?.x_label || "X";
  const yTitle = bb?.y_label || "Y";
  const sTitle = bb?.size_label || "Size";
  const hasSeries = rows.some(r => r.series);

  return {
    ...specBase(rows),
    mark: { type:"circle", opacity: 0.65 },
    encoding: {
      x: { field:"x", type:"quantitative", axis:{ title:xTitle } },
      y: { field:"y", type:"quantitative", axis:{ title:yTitle } },
      size: { field:"size", type:"quantitative", legend:{ title:sTitle } },
      color: hasSeries ? { field:"series", type:"nominal", legend:{ title:null } } : undefined,
      tooltip: [
        { field:"x", type:"quantitative", title:xTitle },
        { field:"y", type:"quantitative", title:yTitle },
        { field:"size", type:"quantitative", title:sTitle },
        ...(hasSeries ? [{ field:"series", type:"nominal" }] : []),
        { field:"label", type:"nominal" }
      ].filter(Boolean)
    }
  };
}

function specMultiSeriesLine(t, d){
  const ms = d.multi_series || d.multi_series_line || d;
  const rows = multiSeriesToRows(ms);
  const xTitle = ms?.x_label || d.series?.x_label || "";
  let yTitle = ms?.y_label || d.series?.y_label || "Value";
  if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

  const palette = getPalette();

  return {
    ...specBase(rows),
    mark: { type:"line", point:{filled:true,size:50}, strokeWidth:2.5 },
    encoding: {
      x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle } },
      color: { 
        field:"series", 
        type:"nominal",
        scale: { range: palette },
        legend:{ title:null, orient:"top", direction:"horizontal", labelFontSize:11 }
      },
      tooltip: [
        { field:"label", type:"nominal" },
        { field:"series", type:"nominal" },
        { field:"value", type:"quantitative", format:",.0f" }
      ]
    }
  };
}

function specMultiSeriesBar(t, d){
  const ms = d.multi_series || d.multi_series_bar || d;
  const rows = multiSeriesToRows(ms);
  const xTitle = ms?.x_label || d.series?.x_label || "";
  let yTitle = ms?.y_label || d.series?.y_label || "Value";
  if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

  const palette = getPalette();

  return {
    ...specBase(rows),
    mark: { type:"bar", cornerRadiusEnd:4 },
    encoding: {
      x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle } },
      color: { 
        field:"series", 
        type:"nominal",
        scale: { range: palette },
        legend:{ title:null, orient:"top", direction:"horizontal", labelFontSize:11 }
      },
      xOffset: { field:"series" },
      tooltip: [
        { field:"label", type:"nominal" },
        { field:"series", type:"nominal" },
        { field:"value", type:"quantitative", format:",.0f" }
      ]
    }
  };
}

function specStackedBar(t, d){
  const st = d.stacked || d.stacked_bar || d;
  const rows = stackedToRows(st);
  const xTitle = st?.x_label || "";
  let yTitle = st?.y_label || "Value";
  if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

  return {
    ...specBase(rows),
    mark: { type:"bar", cornerRadiusEnd:2 },
    encoding: {
      x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle }, stack:"zero" },
      color: { field:"series", type:"nominal", legend:{ title:null } },
      tooltip: [
        { field:"label", type:"nominal" },
        { field:"series", type:"nominal" },
        { field:"value", type:"quantitative" }
      ]
    }
  };
}

function specArea(t, d){
  // area is basically line with area mark
  const typ = normType(t.type);
  const isStacked = (typ === "stacked_area");

  if(isStacked){
    const st = d.stacked || d.stacked_area || d;
    const rows = stackedToRows(st);
    const xTitle = st?.x_label || "";
    let yTitle = st?.y_label || "Value";
    if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

    return {
      ...specBase(rows),
      mark: { type:"area" },
      encoding: {
        x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
        y: { field:"value", type:"quantitative", axis:{ title:yTitle }, stack:"zero" },
        color: { field:"series", type:"nominal", legend:{ title:null } },
        tooltip: [
          { field:"label", type:"nominal" },
          { field:"series", type:"nominal" },
          { field:"value", type:"quantitative" }
        ]
      }
    };
  }

  // plain area from existing d.series
  const labels = d.series?.labels || [];
  const values = d.series?.values || [];
  const rows = seriesToRows(labels, values);
  const xTitle = d.series?.x_label || "";
  let yTitle = d.series?.y_label || "Value";
  if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

  return {
    ...specBase(rows),
    mark: { type:"area" },
    encoding: {
      x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle } },
      tooltip: [
        { field:"label", type:"nominal" },
        { field:"value", type:"quantitative" }
      ]
    }
  };
}

function specHeatmap(t, d){
  const hm = d.heatmap || d;
  const rows = heatmapToRows(hm);
  const xTitle = hm?.x_label || "X";
  const yTitle = hm?.y_label || "Y";
  const vTitle = hm?.value_label || "Value";

  return {
    ...specBase(rows),
    mark: { type:"rect" },
    encoding: {
      x: { field:"x", type:"nominal", axis:{ title:xTitle, labelAngle:0 } },
      y: { field:"y", type:"nominal", axis:{ title:yTitle } },
      color: { field:"value", type:"quantitative", legend:{ title:vTitle } },
      tooltip: [
        { field:"x", type:"nominal", title:xTitle },
        { field:"y", type:"nominal", title:yTitle },
        { field:"value", type:"quantitative", title:vTitle }
      ]
    }
  };
}

function specBoxplot(t, d){
  const bp = d.boxplot || d;
  const rows = boxplotToRows(bp);
  const xTitle = bp?.x_label || "Category";
  const yTitle = bp?.y_label || "Value";

  return {
    ...specBase(rows),
    mark: { type:"boxplot" },
    encoding: {
      x: { field:"category", type:"nominal", axis:{ title:xTitle } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle } },
      tooltip: [
        { field:"category", type:"nominal" },
        { field:"value", type:"quantitative" }
      ]
    }
  };
}

function specHistogram(t, d){
  const vals = histogramValues(d);
  if(vals && vals.length){
    const rows = vals.map(v => ({ value: v }));
    const xTitle = d?.histogram?.x_label || "Value";
    const yTitle = d?.histogram?.y_label || "Count";

    return {
      ...specBase(rows),
      transform: [{ bin: true, field: "value", as: ["bin_start","bin_end"] }],
      mark: { type:"bar", cornerRadiusEnd:4 },
      encoding: {
        x: { field:"bin_start", type:"quantitative", axis:{ title:xTitle } },
        x2:{ field:"bin_end" },
        y: { aggregate:"count", type:"quantitative", axis:{ title:yTitle } },
        tooltip: [
          { field:"bin_start", type:"quantitative", title:"From" },
          { field:"bin_end", type:"quantitative", title:"To" },
          { aggregate:"count", type:"quantitative", title:"Count" }
        ]
      }
    };
  }

  // fallback: if backend gave a normal series (labels are bins already)
  return specFromSeriesTile({ ...t, type:"bar" }, d);
}

function specWaterfall(t, d){
  const wf = d.waterfall || d;
  const rows = waterfallToRows(wf);

  // Vega-lite waterfall approximation:
  // build running total in JS (simpler + robust)
  let running = 0;
  const out = rows.map(r => {
    const kind = r.kind;
    let start = 0, end = 0;

    if(kind === "start"){
      running = r.value;
      start = 0;
      end = running;
    } else if(kind === "end"){
      start = 0;
      end = r.value;
      running = r.value;
    } else {
      // delta
      start = running;
      running = running + r.value;
      end = running;
    }

    return {
      label: r.label,
      start,
      end,
      delta: r.value,
      dir: (r.value >= 0 ? "up" : "down"),
      kind
    };
  });

  const yTitle = wf?.y_label || "Value";

  return {
    ...specBase(out),
    layer: [
      {
        mark: { type:"bar", cornerRadiusEnd:3 },
        encoding: {
          x: { field:"label", type:"ordinal", axis:{ title:null, labelAngle:0 } },
          y: { field:"start", type:"quantitative", axis:{ title:yTitle } },
          y2:{ field:"end" },
          color: { field:"dir", type:"nominal", legend:null }
        }
      },
      {
        mark: { type:"rule" },
        encoding: {
          x: { field:"label", type:"ordinal" },
          y: { field:"end", type:"quantitative" }
        }
      }
    ]
  };
}

function specGauge(t, d){
  const g = d.gauge || d;
  const rows = gaugeToRows(g);
  const label = g?.label || t.title || "";

  // Semi-circle gauge using arc + text
  return {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    width: "container",
    height: "container",
    config: vegaBaseConfig(),
    layer: [
      // background arc
      {
        data: { values: [{ v: 100 }] },
        mark: { type:"arc", innerRadius: 70, outerRadius: 95, startAngle: -Math.PI, endAngle: 0 },
        encoding: { theta: { field:"v", type:"quantitative" } }
      },
      // foreground arc
      {
        data: { values: [{ v: rows[0].pct }] },
        mark: { type:"arc", innerRadius: 70, outerRadius: 95, startAngle: -Math.PI, endAngle: -Math.PI + (rows[0].pct/100)*Math.PI },
        encoding: { theta: { field:"v", type:"quantitative" } }
      },
      // value text
      {
        data: { values: [{ txt: `${rows[0].pct.toFixed(0)}%`, sub: label }] },
        mark: { type:"text", dy: -5, fontSize: 22, fontWeight: 800 },
        encoding: { text: { field:"txt" } }
      },
      {
        data: { values: [{ sub: label }] },
        mark: { type:"text", dy: 18, fontSize: 11 },
        encoding: { text: { field:"sub" } }
      }
    ]
  };
}

function specFromTile(t, d){
  const tt = normType(t?.type);

  // existing payloads
  if(tt === "combo") return specFromComboTile(t, d);
  if(tt === "pie" || tt === "bar" || tt === "line") return specFromSeriesTile(t, d);

  // new types
  if(tt === "area" || tt === "stacked_area") return specArea(t, d);
  if(tt === "scatter") return specScatter(t, d);
  if(tt === "bubble") return specBubble(t, d);
  if(tt === "multi_series_line") return specMultiSeriesLine(t, d);
  if(tt === "multi_series_bar") return specMultiSeriesBar(t, d);
  if(tt === "stacked_bar") return specStackedBar(t, d);
  if(tt === "heatmap") return specHeatmap(t, d);
  if(tt === "boxplot") return specBoxplot(t, d);
  if(tt === "histogram") return specHistogram(t, d);
  if(tt === "waterfall") return specWaterfall(t, d);
  if(tt === "gauge") return specGauge(t, d);

  // fallback
  return specFromSeriesTile({ ...t, type:"bar" }, d);
}

async function createSession(){
  let r = await fetch(`${ORCH}/session`, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({prompt:""})
  });
  if(r.status === 422){
    r = await fetch(`${ORCH}/session`, { method:"POST" });
  }
  const j = await r.json();
  const newSid = j.sid || j.session_id;
  cookieSet("mr_sid", newSid);
  sid = newSid;
  $("sidBadge").textContent = sid;
  return sid;
}

async function ensureSession(){
  if(readQuery("new")==="1"){ cookieDel("mr_sid"); }
  const urlSid = (readQuery("sid")||"").trim();
  const ckSid = (cookieGet("mr_sid")||"").trim();
  if(urlSid){
    sid = urlSid;
    cookieSet("mr_sid", sid);
    $("sidBadge").textContent = sid;
    return sid;
  }
  if(ckSid){
    sid = ckSid;
    $("sidBadge").textContent = sid;
    return sid;
  }
  return await createSession();
}

/* ---------- Chat Interface Functions ---------- */
function addChatMessage(text, isUser = false) {
  console.log("[Chat] Adding message:", text.substring(0, 50), "isUser:", isUser);
  const chatMessages = $("chatMessages");
  if (!chatMessages) {
    console.error("[Chat] chatMessages element not found!");
    return;
  }
  
  const messageDiv = document.createElement("div");
  messageDiv.className = `chat-message chat-message-${isUser ? 'user' : 'ai'}`;
  
  const label = document.createElement("div");
  label.className = "chat-bubble-label";
  label.textContent = isUser ? "You" : "AI Assistant";
  
  const bubble = document.createElement("div");
  bubble.className = "chat-bubble";
  bubble.textContent = text;
  
  messageDiv.appendChild(label);
  messageDiv.appendChild(bubble);
  chatMessages.appendChild(messageDiv);
  
  // Auto-scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

function clearChatMessages() {
  const chatMessages = $("chatMessages");
  if (chatMessages) {
    chatMessages.innerHTML = "";
  }
}

/* ---------- Field map ---------- */
function renderFieldMap(fields){
  $("fCount").textContent = fields.length;
  const body = $("fmBody");
  body.innerHTML = "";
  fields.forEach((f,i) => {
    const row = document.createElement("div"); row.className="fm-row";
    const cField = document.createElement("div"); cField.textContent = f.field ?? f.name ?? "";
    const cDType = document.createElement("div");
    const cAllowed = document.createElement("div");
    const cDesc = document.createElement("div");
    cDType.textContent = f.dtype ?? "";
    cAllowed.textContent = f.allowed ?? "";
    cDesc.textContent = f.description ?? "";
    [cDType,cAllowed,cDesc].forEach((cell, colIdx) => {
      cell.contentEditable = "true";
      cell.classList.add("fm-edit");
      cell.addEventListener("blur", () => {
        const val = cell.textContent.trim();
        if(colIdx===0) fields[i].dtype = val;
        if(colIdx===1) fields[i].allowed = val;
        if(colIdx===2) fields[i].description = val;
      });
    });
    row.append(cField,cDType,cAllowed,cDesc);
    body.appendChild(row);
  });
}

/* ---------- Questions ---------- */
function renderQuestions(qs){
  $("qCount").textContent = qs.length;
  const wrap = $("qWrap");
  wrap.innerHTML = "";
  if(!qs?.length){
    wrap.innerHTML = `<div class="muted">No questions returned.</div>`;
    return;
  }
  qs.forEach((q,idx) => {
    const text = (typeof q === "string" ? q : (q.text || ""));
    const card = document.createElement("div");
    card.className = "card";
    card.style.margin = "0 0 10px";
    card.style.boxShadow = "none";
    card.style.borderRadius = "12px";
    card.innerHTML = `
      <div style="font-size:12px;font-weight:600;margin-bottom:4px">Question ${idx+1}</div>
      <div style="margin:4px 0 8px;font-size:13px">${text}</div>
    `;
    const ta = document.createElement("textarea");
    ta.placeholder = "Your answer (optional)";
    ta.addEventListener("input", () => { answers[idx] = ta.value; });
    card.appendChild(ta);
    wrap.appendChild(card);
  });
}


async function renderVega(el, spec){
  // Guard: if CDN hasn't loaded yet (defer), fail gracefully
  if(typeof vegaEmbed !== "function"){
    el.textContent = "Chart library not loaded yet.";
    return;
  }
  // Always force inline data only (no external urls)
  if(spec?.data?.url){
    delete spec.data.url;
  }

  el.innerHTML = "";
  try{
    await vegaEmbed(el, spec, { actions:false, renderer:"svg" });
  }catch(e){
    console.error("Vega render error", e);
    el.textContent = "Could not render chart.";
  }
}

/* ---------- Simple auto-layout (12-col grid, row-by-row) ---------- */
function autoLayoutTiles(tiles) {
  const cols = 12;
  let cursorX = 0;
  let cursorY = 0;
  let rowH = 0;
  const out = {};

  tiles.forEach(t => {
    const id = t.id || Math.random().toString(36).slice(2);
    const w = Math.min(t.w || 3, cols);
    const h = Math.max(t.h || 2, 2);

    if (cursorX + w > cols) {
      cursorX = 0;
      cursorY += rowH || 2;
      rowH = 0;
    }

    out[id] = { x: cursorX, y: cursorY, w, h };
    cursorX += w;
    rowH = Math.max(rowH, h);
  });

  return out;
}

/* ---------- Preview + interactivity ---------- */
function renderPreviewPayload(tiles){
  const canvas = $("previewCanvas");
  canvas.innerHTML = "";
  if(!tiles?.length){
    const msg = document.createElement("div");
    msg.className = "preview-empty";
    msg.textContent = "No tiles in the design yet. Generate a dashboard first.";
    canvas.appendChild(msg);
    return;
  }
  function hasPos(t){
    return Number.isFinite(t.x) && Number.isFinite(t.y) && Number.isFinite(t.w) && Number.isFinite(t.h);
  }

  // ðŸ”§ If tile count changed (add/remove), reset cached layout so new tiles
  // donâ€™t stack underneath old ones.
  if (Object.keys(localLayout).length &&
      Object.keys(localLayout).length !== tiles.length) {
    localLayout = {};
  }

  const cols = 12;
  const rows = Math.max(1, ...tiles.map(t => (t.y || 0) + (t.h || 2)));
  const needsAuto = tiles.filter(t => !(Number.isFinite(t.x) && Number.isFinite(t.y) && Number.isFinite(t.w) && Number.isFinite(t.h)));
  const autoPos = autoLayoutTiles(needsAuto);

  tiles.forEach(t=>{
    const id = t.id || Math.random().toString(36).slice(2);

    const hasPos = Number.isFinite(t.x) && Number.isFinite(t.y) && Number.isFinite(t.w) && Number.isFinite(t.h);

    const base = { w: t.w || 3, h: t.h || 3, x: t.x || 0, y: t.y || 0 };
    const defaultPos = hasPos ? base : (autoPos[id] || base);
    const stored = localLayout[id] || {};

    const pos = {
      x: Math.min(stored.x ?? defaultPos.x, cols - 1),
      y: Math.min(stored.y ?? defaultPos.y, rows - 1),
      w: Math.min(stored.w ?? defaultPos.w, cols),
      h: Math.min(stored.h ?? defaultPos.h, rows),
    };

    const tile = document.createElement("div");
    tile.className = "tile";
    tile.dataset.id = id;

    tile.style.left   = `${(pos.x/cols)*100}%`;
    tile.style.top    = `${(pos.y/rows)*100}%`;
    tile.style.width  = `${(pos.w/cols)*100}%`;
    tile.style.height = `${(pos.h/rows)*100}%`;

    localLayout[id] = pos;

    const th = document.createElement("div");
    th.className = "t-h";
    const titleSpan = document.createElement("span");
    titleSpan.textContent = t.title || (t.type||"").toUpperCase();
    const sizeSpan = document.createElement("span");
    sizeSpan.className = "muted";
    sizeSpan.textContent = `${pos.w}Ã—${pos.h}`;
    th.append(titleSpan,sizeSpan);

    const tb = document.createElement("div");
    tb.classList.remove("chart-body");
    tb.className = "t-b";
    const d = t.data || {};

    if (d.kpi) {
      const head = document.createElement("div");
      head.className = "kpi";

      // Prefer pretty string if the backend gives one
      let display = "";
      if (typeof d.kpi.pretty === "string" && d.kpi.pretty.trim()) {
        display = d.kpi.pretty.trim();
      } else {
        const raw = Number(d.kpi.value ?? 0);
        const prefix = d.kpi.prefix || "";
        const unit = d.kpi.unit || "";

        if (unit === "%") {
          // boolean-rate KPIs like Return Rate
          display = `${raw * 100 >= 1 ? raw.toFixed(2) : (raw * 100).toFixed(2)}%`;
        } else if (prefix) {
          display = `${prefix}${raw.toLocaleString()}`;
        } else {
          display = raw.toLocaleString();
        }
      }
      const pretty = d.kpi.pretty;
      if (pretty) {
        head.textContent = pretty;
      } else {
        head.textContent = display; // whatever you currently compute for numeric/currency
      }

      const lbl = document.createElement("div");
      lbl.className = "kpi-label";
      lbl.textContent = t.title || "";
      tb.appendChild(lbl);
      tb.appendChild(head);

      if (d.kpi.delta) {
        const pct = d.kpi.delta.pct;
        if (pct !== null && pct !== undefined) {
          const delta = document.createElement("div");
          const good = (pct || 0) >= 0;
          delta.className = "kpi-delta " + (good ? "" : "neg");

          const isRate = (d.kpi.unit === "%");
          delta.textContent = isRate
            ? `${good ? "â–²" : "â–¼"} ${Math.abs(pct).toFixed(2)}pp vs prior period`
            : `${good ? "â–²" : "â–¼"} ${pct.toFixed(1)}% vs prior period`;

          tb.appendChild(delta);
        }
      }
    }
    // --- NEW: render compiled vega-lite spec if present ---
    else if (t.vl_spec || d.vl_spec) {
      tb.classList.add("chart-body");
      const box = document.createElement("div");
      box.className = "chart";
      box.style.width = "100%";
      box.style.height = "100%";
      tb.appendChild(box);

      const spec = (d.vl_spec || t.vl_spec);
      renderVega(box, spec);
    }
    else if(d.combo){
      tb.classList.add("chart-body");

      const box = document.createElement("div");
      box.className = "chart";
      box.style.width = "100%";
      box.style.height = "100%";
      tb.appendChild(box);

      const spec = specFromComboTile(t, d);
      renderVega(box, spec);
    }

    else if (isChartType(t.type) && (d.combo || d.series || d.multi_series || d.stacked || d.scatter || d.bubble || d.heatmap || d.boxplot || d.histogram || d.waterfall || d.gauge)) {
      tb.classList.add("chart-body");
      const box = document.createElement("div");
      box.className = "chart";
      box.style.width = "100%";
      box.style.height = "100%";
      tb.appendChild(box);

      const spec = specFromTile(t, d);
      renderVega(box, spec);
    }
    else if(d.table){
      const wrap = document.createElement("div");
      wrap.className = "tablewrap";
      const tcols = d.table.columns || [];
      const rowsArr = d.table.rows || [];
      let html = "<table><thead><tr>" + tcols.map(c=>`<th>${c}</th>`).join("") + "</tr></thead><tbody>";
      rowsArr.forEach(r=>{
        html += "<tr>" + r.map(v=>`<td>${v ?? ""}</td>`).join("") + "</tr>";
      });
      html += "</tbody></table>";
      wrap.innerHTML = html;
      tb.appendChild(wrap);
    } else {
      tb.textContent = "No data.";
    }

    const handle = document.createElement("div");
    handle.className = "handle";
    tile.append(th,tb,handle);
    canvas.appendChild(tile);

    // drag / resize
    let startX=0,startY=0,startL=0,startT=0,startW=0,startH=0, dragging=false, resizing=false;

    th.addEventListener("mousedown", (e)=>{
      dragging=true;
      startX=e.clientX; startY=e.clientY;
      const r=tile.getBoundingClientRect(), c=canvas.getBoundingClientRect();
      startL=r.left-c.left; startT=r.top-c.top; startW=r.width; startH=r.height;
      e.preventDefault();
    });
    handle.addEventListener("mousedown", (e)=>{
      resizing=true;
      startX=e.clientX; startY=e.clientY;
      const r=tile.getBoundingClientRect(), c=canvas.getBoundingClientRect();
      startL=r.left-c.left; startT=r.top-c.top; startW=r.width; startH=r.height;
      e.preventDefault();
    });

    window.addEventListener("mousemove", (e)=>{
      if(!dragging && !resizing) return;
      const c=canvas.getBoundingClientRect();
      let dx=e.clientX-startX, dy=e.clientY-startY;
      let nl=startL, nt=startT, nw=startW, nh=startH;
      if(dragging){
        nl = Math.max(0, Math.min(startL+dx, c.width-40));
        nt = Math.max(0, Math.min(startT+dy, c.height-40));
      }
      if(resizing){
        nw = Math.max(120, startW+dx);
        nh = Math.max(120, startH+dy);
      }
      let gx = Math.round((nl / c.width) * cols);
      let gy = Math.round((nt / c.height) * rows);
      gx = Math.max(0, Math.min(gx, cols - 1));
      gy = Math.max(0, Math.min(gy, rows - 1));

      let gw = Math.max(2, Math.round((nw / c.width) * cols));
      let gh = Math.max(2, Math.round((nh / c.height) * rows));
      gw = Math.min(gw, cols - gx);
      gh = Math.min(gh, rows - gy);
      tile.style.left = `${(gx/cols)*100}%`;
      tile.style.top  = `${(gy/rows)*100}%`;
      tile.style.width= `${(gw/cols)*100}%`;
      tile.style.height=`${(gh/rows)*100}%`;
      localLayout[id] = {x:gx,y:gy,w:gw,h:gh};
    });
    window.addEventListener("mouseup", ()=>{ dragging=false; resizing=false; });
  });
}

/* ---------- Fetch preview tiles (keep dsl for theme) ---------- */
async function refreshPreview(){
  if(!sid) return;
  try{
    const startVal = $("filterStart").value || null;
    const endVal   = $("filterEnd").value || null;
    const body = {
      filters: {
        date_range: (startVal || endVal) ? { start: startVal, end: endVal } : null,
        categories: currentFilters
      }
    };
    const r = await fetch(`${ORCH}/preview/${encodeURIComponent(sid)}`, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    if(r.ok){
      const j = await r.json();
      if(j.dsl) dsl = j.dsl;
      if(Array.isArray(j.tiles)){
        renderPreviewPayload(j.tiles);
        return;
      }
    }
  }catch(e){
    console.debug("Preview refresh error", e);
  }
  document.body.classList.toggle("dark", (dsl?.theme?.mode || "") === "dark");
  const tiles = (dsl?.pages?.[0]?.tiles||[]).map(t=>({...t, data:null}));
  
  renderPreviewPayload(tiles);
}

/* ---------- Date presets ---------- */
function formatDate(d){
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,"0");
  const day = String(d.getDate()).padStart(2,"0");
  return `${y}-${m}-${day}`;
}
function setQuickRange(mode){
  const now = new Date();
  let start, end;
  if(mode==="YTD"){
    start = new Date(now.getFullYear(),0,1);
    end = now;
  } else if(mode==="LAST_YEAR"){
    start = new Date(now.getFullYear()-1,0,1);
    end = new Date(now.getFullYear()-1,11,31);
  } else if(mode==="THIS_MONTH"){
    start = new Date(now.getFullYear(), now.getMonth(), 1);
    end = now;
  } else if(mode==="LAST_MONTH"){
    const m0 = now.getMonth()-1;
    const y0 = m0 < 0 ? now.getFullYear()-1 : now.getFullYear();
    const m = (m0+12)%12;
    start = new Date(y0, m, 1);
    end = new Date(y0, m+1, 0);
  }
  if(start && end){
    $("filterStart").value = formatDate(start);
    $("filterEnd").value = formatDate(end);
    refreshPreview();
  }
}

/* ---------- Wires ---------- */
async function onNewSession(){
  try{
    setBusy($("newSession"), true, "Startingâ€¦");
    cookieDel("mr_sid");
    await createSession();
    setMsg("aMsg","New session started.","ok");
  }catch(e){
    console.error(e);
    setMsg("aMsg","Could not start a new session.","err");
  }finally{
    setBusy($("newSession"), false);
  }
}

async function onProfile(){
  const btn = $("start");
  setBusy(btn,true,"Profilingâ€¦");
  setMsg("aMsg","");
  try{
    await ensureSession();
    const fd = new FormData();
    fd.append("prompt", ($("prompt").value||"").toString());
    const f = $("file").files[0];
    if(f) fd.append("file", f);
    const r = await fetch(`${ORCH}/profile/${encodeURIComponent(sid)}`, { method:"POST", body: fd });
    const text = await r.text();
    let data={};
    try{ data = JSON.parse(text||"{}"); }catch(e){}
    if(!r.ok) throw new Error(data?.error || text || `HTTP ${r.status}`);
    schemaFields = data.fields || data.schema_table || [];
    questions = (data.questions || []).map(q => (typeof q==="string" ? {text:q} : q));
    renderFieldMap(schemaFields);
    show("stepB", true);
    renderQuestions(questions);
    show("stepC", true);
    setMsg("aMsg", `Profiling complete. Detected ${schemaFields.length} fields Â· ${questions.length} questions.`, "ok");
  }catch(e){
    console.error(e);
    setMsg("aMsg","Profiling failed. Check logs.","err");
  }finally{
    setBusy(btn,false);
  }
}

async function onGenerateDesign(){
  const btn = $("genDesign");
  setBusy(btn,true,"Designingâ€¦");
  setMsg("cMsg","");
  try{
    const payload = { schema_table: schemaFields, answers: Object.values(answers||{}) };
    const r = await fetch(`${ORCH}/design/${encodeURIComponent(sid)}`, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    const text = await r.text();
    let data={};
    try{ data = JSON.parse(text||"{}"); }catch(e){}
    if(!r.ok) throw new Error(data?.error || text || `HTTP ${r.status}`);
    dsl = data.dsl || data;
    show("stepD", true);
    currentFilters = [];
    localLayout = {};
    // default to YTD when the dashboard first appears
    setQuickRange("YTD");

    // Add initial AI summary to chat
    clearChatMessages();
    const notes = (dsl && Array.isArray(dsl.__notes)) ? dsl.__notes : null;
    if (notes && notes.length) {
      setMsg("cMsg", "Design created (YTD applied). AI notes: " + notes.join(" Â· "), "ok");
      addChatMessage("Dashboard created! Here's what I've included:\n\nâ€¢ " + notes.join("\nâ€¢ "), false);
    } else {
      setMsg("cMsg","Design created (YTD applied).","ok");
      addChatMessage("Dashboard created successfully! You can now ask me to make changes to any chart or add new visualizations.", false);
    }
  }catch(e){
    console.error(e);
    setMsg("cMsg","Failed to create design. Check logs.","err");
  }finally{
    setBusy(btn,false);
  }
}

async function onApplyChange(){
  console.log("[Chat] onApplyChange called");
  const btn = $("applyChange");
  const change = ($("changeText").value||"").trim();
  
  if(!change){
    addChatMessage("Please describe the changes you want to make.", false);
    return;
  }
  
  // Add user message to chat
  addChatMessage(change, true);
  
  setBusy(btn,true,"Sendingâ€¦");
  
  try{
    const r = await fetch(`${ORCH}/edit/${encodeURIComponent(sid)}`, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ change })
    });
    const j = await r.json();
    dsl = j.dsl || dsl;

    if (j && j.clarify) {
      // AI needs clarification
      addChatMessage("â“ " + j.clarify, false);
      setBusy(btn,false);
      return;
    }

    await refreshPreview();

    // AI response message
    const notes = (dsl && Array.isArray(dsl.__notes)) ? dsl.__notes : null;
    let responseText = "âœ“ Change applied successfully!";
    
    if (notes && notes.length) {
      responseText += "\n\nâ€¢ " + notes.join("\nâ€¢ ");
    }
    
    addChatMessage(responseText, false);

    $("changeText").value = "";
  }catch(e){
    console.error("[Chat] Error:", e);
    addChatMessage("âŒ Sorry, I couldn't apply that change. Please try rephrasing your request.", false);
  }finally{
    setBusy(btn,false);
  }
}

async function onSaveLayout(){
  const tiles = (dsl?.pages?.[0]?.tiles||[]).map(t=>{
    const pos = localLayout[t.id] || {x:t.x,y:t.y,w:t.w,h:t.h};
    return {id:t.id, x:pos.x, y:pos.y, w:pos.w, h:pos.h};
  });
  try{
    const r = await fetch(`${ORCH}/edit/${encodeURIComponent(sid)}`, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ tiles })
    });
    const j = await r.json();
    dsl = j.dsl || dsl;
    setMsg("dMsg","Layout saved.","ok");
  }catch(e){
    console.error(e);
    setMsg("dMsg","Layout save failed.","err");
  }
}

function onClearFilters(){
  $("filterStart").value = "";
  $("filterEnd").value = "";
  currentFilters = [];
  refreshPreview();
}
function onExportPdf(){ window.print(); }

/* ---------- Boot ---------- */
(async () => {
  try {
    await ensureSession();
  } catch(e) {
    console.error(e);
    setMsg("aMsg","Could not create a session. Please reload.","err");
  }
  $("newSession").addEventListener("click", onNewSession, {passive:true});
  $("start").addEventListener("click", onProfile, {passive:true});
  $("genDesign").addEventListener("click", onGenerateDesign, {passive:true});
  $("applyChange").addEventListener("click", onApplyChange, {passive:true});
  $("saveLayout").addEventListener("click", onSaveLayout, {passive:true});
  $("clearFilters").addEventListener("click", onClearFilters, {passive:true});
  $("exportPdf").addEventListener("click", onExportPdf, {passive:true});
  $("applyFilters").addEventListener("click", ()=>refreshPreview(), {passive:true});
  $("btnYTD").addEventListener("click", ()=>setQuickRange("YTD"), {passive:true});
  $("btnLastYear").addEventListener("click", ()=>setQuickRange("LAST_YEAR"), {passive:true});
  $("btnThisMonth").addEventListener("click", ()=>setQuickRange("THIS_MONTH"), {passive:true});
  $("btnLastMonth").addEventListener("click", ()=>setQuickRange("LAST_MONTH"), {passive:true});
})();
</script>
</body>
</html>