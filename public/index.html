<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>MR Analytics Hub â€“ Dashboard Builder</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <script src="https://cdn.jsdelivr.net/npm/vega@5" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@5" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@6" defer></script>
  <style>
    :root {
      --bg: #f5f5f7;
      --surface: #ffffff;
      --ink: #111111;
      --muted: #6b7280;
      --line: #e5e7eb;
      --accent: #2563eb;
      --accent-soft: #eff6ff;
      --ok: #16a34a;
      --err: #b91c1c;
      --radius-lg: 14px;
      --radius-sm: 8px;
      --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.08);
    }

    * { box-sizing:border-box; }

    html, body {
      margin:0;
      padding:0;
      background: radial-gradient(circle at top left, #f9fafb 0, #eef2ff 40%, #f5f5f7 100%);
      color:var(--ink);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", Segoe UI, Roboto, sans-serif;
    }

    .wrap {
      max-width: 1480px;
      margin: 0 auto;
      padding: 24px 20px 40px;
    }

    h1 {
      margin:0 0 4px;
      font-size: 32px;
      letter-spacing: .02em;
    }

    h2 {
      margin:0 0 6px;
      font-size: 18px;
      letter-spacing:.02em;
    }

    .muted {
      color:var(--muted);
      font-size:13px;
    }

    .row {
      display:flex;
      align-items:center;
      gap:12px;
    }

    .sid-badge {
      background:rgba(15,23,42,0.03);
      border:1px solid rgba(148,163,184,0.5);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
    }

    .pill {
      padding:4px 10px;
      border-radius:999px;
      background:rgba(37,99,235,0.06);
      color:#1d4ed8;
      font-size:11px;
      font-weight:500;
    }

    .card {
      border-radius:var(--radius-lg);
      background:var(--surface);
      box-shadow:var(--shadow-soft);
      padding:16px 18px 18px;
      margin-top:16px;
      border:1px solid rgba(148,163,184,0.25);
    }

    .toolbar {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:8px;
    }

    button {
      appearance:none;
      background:#C45AFF;
      color:#fff;
      border:5px solid #D892FF;
      padding:9px 14px;
      border-radius:50px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      box-shadow:0 4px 12px rgba(196, 90, 255, 0.25);
      transition:all .2s ease-in-out;
    }
    button:hover { 
      background:#D892FF;
      transform:scale(1.05);
      box-shadow:0 6px 16px rgba(196, 90, 255, 0.35);
    }
    button:active { 
      transform:scale(1);
      box-shadow:0 4px 12px rgba(196, 90, 255, 0.25);
    }
    button.secondary {
      background:#f9fafb;
      color:#111827;
      border:1px solid #e5e7eb;
      box-shadow:none;
    }
    button.ghost {
      background:transparent;
      color:#111827;
      border:1px dashed #d4d4d8;
      box-shadow:none;
    }
    button.chip {
      padding:6px 10px;
      font-size:12px;
      border-radius:999px;
      background:#f3f4ff;
      color:#4338ca;
      border:1px solid rgba(129,140,248,0.6);
      box-shadow:none;
    }
    button.chip[data-active="1"] {
      background:#4f46e5;
      color:#eef2ff;
      border-color:#4f46e5;
    }
    button[disabled] {
      opacity:.55;
      cursor:not-allowed;
      box-shadow:none;
      transform:none;
    }

    input[type="text"],
    input[type="email"],
    input[type="date"],
    select,
    textarea {
      width:100%;
      padding:9px 11px;
      border-radius:999px;
      border:1px solid #e5e7eb;
      background:#f9fafb;
      font-size:13px;
      outline:none;
      transition:border .1s ease-out, box-shadow .1s ease-out, background .1s ease-out;
    }
    input[type="date"] {
      padding-inline:12px;
    }
    textarea {
      border-radius:12px;
      min-height: 120px;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      resize:vertical;
    }
    input:focus,
    textarea:focus,
    select:focus {
      border-color:#4f46e5;
      box-shadow:0 0 0 1px rgba(79,70,229,0.5);
      background:#ffffff;
    }

    .hidden { display:none !important; }

    .err { color:var(--err); font-size:13px; }
    .ok { color:var(--ok); font-size:13px; }

    /* Field Map */
    .fm-wrap {
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
      background:#f9fafb;
    }
    .fm-head,
    .fm-row {
      display:grid;
      grid-template-columns: 220px 140px 220px 1fr;
      align-items:flex-start;
      font-size:12px;
    }
    .fm-head {
      background:#f3f4ff;
      border-bottom:1px solid var(--line);
      font-weight:600;
    }
    .fm-head div,
    .fm-row div {
      padding:8px 10px;
      border-right:1px solid var(--line);
    }
    .fm-head div:last-child,
    .fm-row div:last-child {
      border-right:0;
    }
    .fm-body {
      max-height: 320px;
      overflow:auto;
      background:#fff;
    }
    .fm-row {
      border-bottom:1px solid var(--line);
    }
    .fm-row:nth-child(even) {
      background:#f9fafb;
    }
    .fm-edit {
      outline:none;
      border-radius:6px;
      min-height:24px;
    }
    .fm-edit:focus {
      box-shadow: inset 0 0 0 1px #93c5fd;
      background:#eff6ff;
    }

    /* Preview grid */
    #previewToolbar {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      margin:8px 0 12px;
    }

    #previewPanel {
      border-radius:20px;
      background:radial-gradient(circle at top left, #ffffff, #f3f4ff 40%, #ffffff 90%);
      padding:14px 14px 10px;
      border:1px solid rgba(148,163,184,0.4);
      box-shadow:var(--shadow-soft);
    }

    #previewCanvas {
      position:relative;
      min-height: 600px;
      height: calc(100vh - 220px);
      max-height: 960px;
      background:
        linear-gradient(135deg, rgba(248,250,252,1), rgba(241,245,249,1));
      overflow:hidden;
    }

    .tile {
      position:absolute;
      border-radius:12px;
      background:#ffffff;
      display:flex;
      flex-direction:column;
      box-shadow:0 1px 3px rgba(15,23,42,0.08), 0 4px 12px rgba(15,23,42,0.04);
      border:1px solid rgba(226,232,240,0.8);
      overflow:hidden;
      transition: box-shadow 0.2s ease;
    }
    .tile:hover {
      box-shadow:0 2px 8px rgba(15,23,42,0.12), 0 8px 20px rgba(15,23,42,0.06);
    }
    .tile .t-h {
      font-weight:600;
      padding:6px 12px 5px;
      border-bottom:1px solid #f1f5f9;
      cursor:move;
      user-select:none;
      display:flex;
      justify-content:center;
      align-items:center;
      font-size:12px;
      color:#374151;
      background:#fafbfc;
      gap:8px;
      position:relative;
      min-height:28px;
    }
    .tile .t-h > span:first-child {
      text-align:center;
      line-height:1.3;
      word-wrap:break-word;
      overflow-wrap:break-word;
    }
    .tile .t-h span.muted {
      font-size:11px;
      color:#9ca3af;
      flex-shrink:0;
      position:absolute;
      right:10px;
      opacity:0;
      transition:opacity 0.2s;
    }
    .tile:hover .t-h span.muted {
      opacity:1;
    }
    .tile .t-b {
      padding:6px 8px 8px;
      color:#111827;
      font-size:12px;
      flex:1;
      overflow:hidden;
      position:relative;
      background:#ffffff;
    }
    .tile .t-b.kpi-body {
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:12px 16px;
    }

    .kpi {
      font-size:42px;
      font-weight:800;
      letter-spacing:.02em;
      margin-bottom:6px;
      line-height:1.1;
    }
    .kpi-label {
      font-size:12px;
      color:#6b7280;
      margin-bottom:6px;
    }
    .kpi-delta {
      margin-top:4px;
      font-size:12px;
      font-weight:600;
      color:#16a34a;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:4px;
    }
    .kpi-delta.neg { color:#b91c1c; }


    .tooltip {
      position:absolute;
      pointer-events:none;
      background:#020617;
      color:#f9fafb;
      font-size:11px;
      padding:4px 7px;
      border-radius:6px;
      transform:translate(-50%,-120%);
      white-space:nowrap;
      display:none;
      box-shadow:0 10px 25px rgba(15,23,42,0.4);
    }

    .preview-empty {
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      color:#9ca3af;
      font-size:14px;
      background:repeating-linear-gradient(
          45deg,
          #f9fafb,
          #f9fafb 12px,
          #eef2ff 12px,
          #eef2ff 24px
      );
    }

    .tablewrap {
      overflow:auto;
      height:100%;
      border-radius:10px;
      border:1px solid #e5e7eb;
      background:#f9fafb;
    }
    .tablewrap table {
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    .tablewrap th,
    .tablewrap td {
      border-bottom:1px solid #e5e7eb;
      padding:6px 8px;
      text-align:left;
    }
    .tablewrap th {
      background:#f3f4ff;
      font-weight:600;
    }
    .tablewrap tr:nth-child(even) td {
      background:#f9fafb;
    }

    .handle {
      position:absolute;
      width:14px;
      height:14px;
      right:4px;
      bottom:4px;
      cursor:nwse-resize;
      background:
        linear-gradient(135deg, transparent 0, transparent 45%, #cbd5f5 45%, #cbd5f5 55%, transparent 55%, transparent 100%);
      border-radius:4px;
      opacity:0.7;
    }

    .promptbar {
      display:flex;
      gap:8px;
      align-items:flex-start;
      margin-top:16px;
    }
    .promptbar textarea {
      min-height: 70px;
    }

    .badge {
      padding:2px 6px;
      border-radius:999px;
      background:#fee2e2;
      color:#b91c1c;
      font-size:10px;
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:.08em;
    }

    .date-group {
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
    }

    .tile .t-b.chart-body{
      padding: 6px 8px 8px;   /* tighter than default */
    }

    .tile .t-b.chart-body .chart{
      height: 100%;
      width: 100%;
      display: flex;
    }

    .tile .t-b.chart-body .chart svg{
      width: 100%;
      height: 100%;
      display: block;
    }

    .chart > .vega-embed,
    .chart > .vega-embed > .vega-actions,
    .chart > .vega-embed > details,
    .chart canvas,
    .chart svg {
      width: 100% !important;
      height: 100% !important;
    }

    .chart > .vega-embed { display:flex; flex:1; }
    .chart > .vega-embed details { display:none; } /* belt & braces */

    .msg.warn {
      background: #fff7ed;
      border-left: 4px solid #f59e0b;

/* ========== CHAT INTERFACE STYLES ========== */
.chat-wrapper {
  margin-top: 30px !important;
  margin-bottom: 30px !important;
  max-width: 1000px !important;
  margin-left: auto !important;
  margin-right: auto !important;
}

.chat-title {
  text-align: center !important;
  font-size: 24px !important;
  font-weight: 600 !important;
  color: #690697 !important;
  margin-bottom: 8px !important;
}

.chat-subtitle {
  text-align: center !important;
  font-size: 14px !important;
  color: #666 !important;
  margin-bottom: 20px !important;
}

.chat-container {
  border-radius: 12px !important;
  background: white !important;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1) !important;
  border: 2px solid #690697 !important;
  overflow: hidden !important;
}

.chat-header {
  padding: 16px 20px !important;
  background: linear-gradient(135deg, #690697 0%, #9d4edd 100%) !important;
  color: white !important;
  font-weight: 600 !important;
  font-size: 16px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 8px !important;
  border-bottom: 2px solid rgba(255, 255, 255, 0.2) !important;
}

.chat-messages {
  max-height: 400px !important;
  min-height: 120px !important;
  overflow-y: auto !important;
  padding: 1.5em !important;
  display: flex !important;
  flex-direction: column !important;
  gap: 0.3em !important;
  background: #f9f9f9 !important;
}

.chat-messages:empty::before {
  content: "AI responses will appear here..." !important;
  color: var(--muted) !important;
  font-size: 13px !important;
  font-style: italic !important;
  text-align: center !important;
  display: block !important;
  padding: 40px 20px !important;
}

.chat-message {
  display: flex !important;
  flex-direction: column !important;
  animation: slideIn 0.3s ease-out !important;
  margin: 0.3em 0 !important;
}

@keyframes slideIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.chat-bubble {
  max-width: 75% !important;
  padding: 0.5em 1em !important;
  border-radius: 12px !important;
  line-height: 1.5 !important;
  font-size: 13px !important;
  word-wrap: break-word !important;
  white-space: pre-wrap !important;
}

.chat-message-user {
  align-items: flex-end !important;
}

.chat-message-user .chat-bubble {
  background: #690697 !important;
  color: white !important;
  align-self: flex-end !important;
  border-bottom-right-radius: 4px !important;
  box-shadow: 0 4px 12px rgba(105, 6, 151, 0.25) !important;
}

.chat-message-ai {
  align-items: flex-start !important;
}

.chat-message-ai .chat-bubble {
  background: #e2e2e2 !important;
  color: black !important;
  align-self: flex-start !important;
  border-bottom-left-radius: 4px !important;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05) !important;
}

.chat-bubble-label {
  font-size: 10px !important;
  font-weight: 600 !important;
  text-transform: uppercase !important;
  letter-spacing: 0.05em !important;
  margin-bottom: 4px !important;
  opacity: 0.7 !important;
}

.chat-message-user .chat-bubble-label {
  color: #690697 !important;
  align-self: flex-end !important;
}

.chat-message-ai .chat-bubble-label {
  color: #690697 !important;
  align-self: flex-start !important;
}

.chat-thinking {
  display: flex !important;
  flex-direction: column !important;
  align-items: flex-start !important;
  margin: 0.5em 0 !important;
}

.chat-thinking-bubble {
  max-width: 75% !important;
  padding: 12px 16px !important;
  border-radius: 12px !important;
  line-height: 1.5 !important;
  font-size: 13px !important;
  background: #e2e2e2 !important;
  color: #666 !important;
  font-style: italic !important;
  opacity: 0.8 !important;
  animation: pulse 1.5s ease-in-out infinite !important;
}

@keyframes pulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

.chat-input-area {
  padding: 0.75em 1.5em !important;
  background: #f9f9f9 !important;
  border-top: 1px solid var(--line) !important;
  display: flex !important;
  gap: 8px !important;
}

.chat-input-area textarea {
  flex: 1 !important;
  min-height: 60px !important;
  resize: vertical !important;
  padding: 10px 12px !important;
  border-radius: 6px !important;
  border: 1px solid #ccc !important;
  background: white !important;
  font-size: 13px !important;
  font-family: inherit !important;
}

.chat-input-area textarea:focus {
  border-color: #690697 !important;
  box-shadow: 0 0 0 2px rgba(105, 6, 151, 0.1) !important;
  outline: none !important;
}

.chat-input-area button {
  align-self: flex-end !important;
  white-space: nowrap !important;
  padding: 0.5em 1.5em !important;
  font-size: 1em !important;
  background-color: #C45AFF !important;
  color: white !important;
  border: 5px solid #D892FF !important;
  border-radius: 50px !important;
  cursor: pointer !important;
  transition: all 0.2s ease-in-out !important;
  font-weight: 500 !important;
}

.chat-input-area button:hover {
  background-color: #D892FF !important;
  transform: scale(1.05) !important;
}

.chat-input-area button:hover {
  background-color: #D892FF;
  transform: scale(1.05);
}

.chat-input-area button:active {
  background-color: #C45AFF;
  transform: scale(1);
}

    }

    body.dark {
  --bg:#0b1220;
  --surface:#0f172a;
  --ink:#e5e7eb;
  --muted:#94a3b8;
  --line:#1f2937;
}

/* ========== SUGGESTIONS CAROUSEL ========== */
.suggestions-panel {
  margin-top: 20px;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  background: #ffffff;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0,0,0,0.04);
}
.suggestions-panel.hidden { display: none; }
.suggestions-header {
  display: flex;
  align-items: center;
  padding: 12px 20px;
  cursor: pointer;
  background: linear-gradient(135deg, #f9fafb, #f3f4f6);
  border-bottom: 1px solid #e5e7eb;
  user-select: none;
}
.suggestions-header:hover { background: linear-gradient(135deg, #f3f4f6, #e5e7eb); }
.suggestions-toggle {
  font-size: 10px; color: #6b7280; margin-right: 12px;
  transition: transform 0.2s; display: inline-block;
}
.suggestions-toggle.open { transform: rotate(90deg); }
.suggestions-body {
  display: flex; gap: 16px; padding: 16px 20px;
  overflow-x: auto; scroll-behavior: smooth; background: #fafbfc;
}
.suggestions-body.hidden { display: none; }
.suggestions-body::-webkit-scrollbar { height: 6px; }
.suggestions-body::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
.suggestion-card {
  flex: 0 0 260px; border: 1.5px solid #e5e7eb; border-radius: 10px;
  background: #ffffff; cursor: default;
  transition: border-color 0.2s, box-shadow 0.2s, transform 0.15s;
  display: flex; flex-direction: column; overflow: hidden;
}
.suggestion-card:hover {
  border-color: #7c3aed; box-shadow: 0 4px 16px rgba(124,58,237,0.12);
  transform: translateY(-2px);
}
.sg-preview {
  height: 120px; display: flex; align-items: center; justify-content: center;
  background: #f9fafb; border-bottom: 1px solid #f1f5f9;
  overflow: hidden; position: relative;
}
.sg-preview .sg-loading { font-size: 11px; color: #9ca3af; }
.sg-content { padding: 10px 14px; display: flex; flex-direction: column; gap: 3px; flex: 1; }
.sg-type { font-size: 10px; text-transform: uppercase; letter-spacing: 0.06em; color: #7c3aed; font-weight: 700; }
.sg-title { font-size: 13px; font-weight: 600; color: #111827; line-height: 1.3; }
.sg-rationale { font-size: 11px; color: #6b7280; line-height: 1.4; flex: 1; }
.sg-add-btn {
  margin: 0 14px 12px; padding: 7px 0; font-size: 12px; font-weight: 600;
  color: #7c3aed; background: #f5f3ff; border: 1.5px solid #ddd6fe;
  border-radius: 8px; cursor: pointer; text-align: center;
  transition: background 0.15s, color 0.15s;
}
.sg-add-btn:hover { background: #7c3aed; color: #ffffff; }

/* ========== TILE REMOVE BUTTON ========== */
.tile-remove-btn {
  position: absolute; top: 4px; right: 6px; z-index: 5;
  width: 20px; height: 20px; border-radius: 50%;
  background: rgba(239,68,68,0.08); border: none;
  color: #ef4444; font-size: 13px; line-height: 20px;
  text-align: center; cursor: pointer;
  opacity: 0; transition: opacity 0.15s, background 0.15s;
  display: flex; align-items: center; justify-content: center;
}
.tile:hover .tile-remove-btn { opacity: 1; }
.tile-remove-btn:hover { background: #ef4444; color: #fff; }

  </style>
</head>
<body>
<div class="wrap">
  <div class="row" style="margin-bottom:6px">
    <div style="flex:1">
      <h1>Dashboard Builder</h1>
      <div class="muted">Upload your data, answer a few questions, and let the assistant design the first version.</div>
    </div>
    <div class="row">
      <span class="muted">Session</span>
      <span id="sidBadge" class="sid-badge">â€“</span>
      <button id="newSession" class="secondary" type="button">New session</button>
    </div>
  </div>

  <!-- STEP 1 -->
  <div class="card" id="stepA">
    <div class="row" style="justify-content:space-between;align-items:flex-end">
      <div>
        <h2>1) Describe your business & upload a sample</h2>
        <div class="muted">Tell the assistant what you care about (channels, products, regions, goals).</div>
      </div>
      <span class="pill">Start here</span>
    </div>
    <textarea id="prompt" placeholder="E.g. We&#39;re an online sportswear retailer. I care about revenue, profit, orders, returns, and new vs existing customers by marketing channel."></textarea>
    <div class="toolbar">
      <input id="file" type="file" accept=".csv,.xlsx"/>
      <button id="start" type="button">Profile dataset</button>
      <span id="aMsg" class="muted"></span>
    </div>
  </div>

  <!-- STEP 2 -->
  <div class="card hidden" id="stepB">
    <h2>2) Field Map</h2>
    <div class="muted">Detected <span id="fCount">0</span> fields Â· <span id="qCount">0</span> clarifying questions.</div>
    <div class="fm-wrap" style="margin-top:10px">
      <div class="fm-head">
        <div>field</div><div>dtype</div><div>allowed</div><div>description</div>
      </div>
      <div id="fmBody" class="fm-body"></div>
    </div>
    <div style="margin-top:10px">
      <span id="bMsg" class="muted"></span>
    </div>
  </div>

  <!-- STEP 3 -->
  <div class="card hidden" id="stepC">
    <h2>3) Questions</h2>
    <div class="muted" style="margin-bottom:10px">These refine how the dashboard thinks about your data and time-grain.</div>
    <div id="qWrap"></div>
    <div style="margin-top:10px; display:flex; gap:10px; align-items:center">
      <button id="genDesign" type="button">Generate dashboard</button>
      <span id="cMsg" class="muted"></span>
    </div>
  </div>

  <!-- STEP 4 -->
  <div class="card hidden" id="stepD">
    <div class="row" style="justify-content:space-between;align-items:flex-end;margin-bottom:6px">
      <h2>4) Design & Preview</h2>
      <span class="muted">Drag tiles, resize, and tweak the design. Date filters and prompts update everything.</span>
    </div>

    <div id="previewToolbar">
      <div class="date-group">
        <button class="secondary" type="button" style="padding:7px 11px;font-size:12px" disabled>Filters</button>
        <span class="muted" style="font-size:12px">Start</span>
        <input id="filterStart" type="date"/>
        <span class="muted" style="font-size:12px">End</span>
        <input id="filterEnd" type="date"/>
        <button id="applyFilters" class="secondary" type="button">Apply</button>
        <button id="clearFilters" class="ghost" type="button">Clear filters</button>
        <span id="filterStatus" class="muted" style="font-size:12px;margin-left:8px;display:inline-block;min-width:160px"></span>
      </div>
      <div class="date-group">
        <button class="chip" type="button" id="btnYTD">YTD</button>
        <button class="chip" type="button" id="btnLastYear">Last year</button>
        <button class="chip" type="button" id="btnThisMonth">This month</button>
        <button class="chip" type="button" id="btnLastMonth">Last month</button>
      </div>
      <div style="flex:1"></div>
      <button id="saveLayout" class="ghost" type="button" title="Persist current tile positions">Save layout</button>
      <button id="exportPdf" class="secondary" type="button" title="Print to PDF">Export PDF</button>
      <button id="saveDashboard" type="button" title="Save to your account" style="display:none;background:#7c3aed;color:#fff;padding:8px 18px;border-radius:8px;font-weight:600;font-size:13px;border:none;cursor:pointer">ðŸ’¾ Save Dashboard</button>
      <span id="dMsg" class="muted" style="display:none;"></span>
    </div>

    <div id="previewPanel">
      <div id="previewCanvas"></div>
    </div>
    <div class="muted" style="margin-top:8px">Click chart elements to filter (coming soon). Drag/resize tiles to customise layout.</div>

    <!-- Suggestions Carousel -->
    <div id="suggestionsPanel" class="suggestions-panel hidden">
      <div class="suggestions-header" onclick="toggleSuggestions()">
        <span class="suggestions-toggle open" id="suggestionsToggle">&#9654;</span>
        <h3 style="margin:0;font-size:14px;font-weight:600;color:#374151">Suggested Charts</h3>
        <span class="muted" style="font-size:12px;margin-left:10px" id="suggestionsCount"></span>
        <span style="flex:1"></span>
        <span class="muted sg-collapse-hint" style="font-size:11px">click to collapse</span>
      </div>
      <div class="suggestions-body" id="suggestionsBody"></div>
    </div>

    <!-- Chat Interface -->
    <div class="chat-wrapper">
      <h2 class="chat-title">AI Dashboard Assistant</h2>
      <p class="chat-subtitle">Request changes to your dashboard using the chat below</p>
      
      <div class="chat-container" style="
        border-radius: 8px;
        background: #f9f9f9;
        border: 1px solid #ccc;
        overflow: hidden;
      ">
        <div class="chat-header" style="display: none;">
          ðŸ’¬ Chat
        </div>
        <div class="chat-messages" id="chatMessages" style="background: #f9f9f9; padding: 1.5em;">
          <!-- Messages will be dynamically added here -->
        </div>
        <div class="chat-input-area" style="padding: 0.75em 1.5em;">
          <textarea id="changeText" placeholder="Describe the changes you want... (e.g., 'change the bar chart to a pie chart')"></textarea>
          <button id="applyChange" type="button" style="
            padding: 0.5em 1.5em;
            font-size: 1em;
            background-color: #C45AFF;
            color: white;
            border: 5px solid #D892FF;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-weight: 500;
          "
          onmouseover="this.style.backgroundColor='#D892FF'; this.style.transform='scale(1.05)'"
          onmouseout="this.style.backgroundColor='#C45AFF'; this.style.transform='scale(1)'">Send</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
const ORCH = "https://mr-orchestrator-585407302606.europe-west2.run.app";

const $ = (id) => document.getElementById(id);
function setMsg(id, text, cls="muted"){ const el=$(id); if(!el) return; el.className=cls; el.textContent = text||""; }
function show(id, flag){ $(id).classList.toggle("hidden", !flag); }
function setBusy(btn, on, label="Workingâ€¦"){
  if(!btn) return;
  btn.disabled = !!on;
  if(on){
    btn.dataset._t = btn.textContent;
    btn.textContent = label;
  } else if(btn.dataset._t){
    btn.textContent = btn.dataset._t;
    delete btn.dataset._t;
  }
}
function readQuery(k){ const p = new URLSearchParams(location.search); return p.get(k); }
function cookieGet(name){ return (`; ${document.cookie}`).split(`; ${name}=`).pop().split(';')[0] || ""; }
function cookieSet(name, value){ document.cookie = `${name}=${value}; Max-Age=3600; Path=/; SameSite=None; Secure`; }
function cookieDel(name){ document.cookie = `${name}=; Max-Age=0; Path=/; SameSite=None; Secure`; }

let sid = null;
let schemaFields = [];
let questions = [];
let answers = {};
let dsl = null;
let currentFilters = []; // reserved for future cross-filter support
let localLayout = {};   // tileId -> {x,y,w,h}

/* ------- palette helper (reads dsl.theme.palette) ------- */
function getPalette(){
  const def = ["#6366f1","#f97316","#10b981","#ec4899","#8b5cf6","#06b6d4","#facc15"];
  try{
    const pal = dsl?.theme?.palette;
    if(Array.isArray(pal) && pal.length) return pal;
  }catch(e){}
  return def;
}
function getCurrency(){ return dsl?.theme?.currency || "Â£"; }

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function seriesToRows(labels, values){
  const rows = [];
  for(let i=0;i<Math.max(labels?.length||0, values?.length||0);i++){
    rows.push({ label: String(labels?.[i] ?? ""), value: Number(values?.[i] ?? 0) });
  }
  return rows;
}

function vegaBaseConfig(){
  const palette = getPalette();
  return {
    background: null,
    padding: 2,
    view: { stroke: null },
    axis: {
      labelFont: "system-ui",
      titleFont: "system-ui",
      labelFontSize: 11,
      titleFontSize: 11,
      gridColor: "#e5e7eb",
      tickColor: "#d1d5db",
      domainColor: "#d1d5db",
      labelColor: "#6b7280",
      titleColor: "#6b7280",
      tickCount: 5
    },
    legend: {
      labelFont: "system-ui",
      titleFont: "system-ui",
      labelFontSize: 11,
      titleFontSize: 11,
      labelColor: "#6b7280",
      titleColor: "#6b7280"
    },
    range: {
      category: palette,
      ordinal: palette
    }
  };
}

/**
 * Build a Vega-Lite spec from your existing d.series payload.
 * Uses t.type to pick bar/line/pie.
 */
function getAxisConfig(t){
  const rot = Number(t?.axis?.x?.rotate ?? 0);
  const angle = (rot === 90 ? 90 : rot === 45 ? 45 : rot === -45 ? -45 : 0);
  return {
    xLabelAngle: angle,
    // when rotated, reduce tick density a bit
    xTickCount: angle ? 4 : 6
  };
}

function specFromSeriesTile(t, d){
  const labels = d.series?.labels || [];
  const values = d.series?.values || [];
  const rows = seriesToRows(labels, values);

  const xLabel = d.series?.x_label || "";
  let yLabel = d.series?.y_label || "";
  if(/amount|revenue|sales|profit|turnover/i.test(yLabel)){
    yLabel = `${yLabel} (${getCurrency()})`;
  }

  const typ = String(t.type || "").toLowerCase();
  const ax = getAxisConfig(t);
  // Base
  const common = {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    data: { values: rows },
    width: "container",
    height: "container",
    config: vegaBaseConfig()
  };

  if(typ === "pie"){
    return {
      ...common,
      mark: { type: "arc", innerRadius: 40 },
      encoding: {
        theta: { field: "value", type: "quantitative" },
        color: { field: "label", type: "nominal", legend: { title: null } },
        tooltip: [
          { field: "label", type: "nominal" },
          { field: "value", type: "quantitative" }
        ]
      }
    };
  }

  if(typ === "line"){
    return {
      ...common,
      mark: { type: "line", point: { filled: true, size: 40 } },
      encoding: {
        x: { field: "label", type: "ordinal", axis: { title: xLabel, labelAngle: ax.xLabelAngle, tickCount: ax.xTickCount } },
        y: { field: "value", type: "quantitative", axis: { title: yLabel, tickCount: 5 } },
        tooltip: [
          { field: "label", type: "nominal" },
          { field: "value", type: "quantitative" }
        ]
      }
    };
  }

  // default = bar
  const palette = getPalette();
  return {
    ...common,
    mark: { type: "bar", cornerRadiusEnd: 4 },
    encoding: {
      x: { field: "label", type: "ordinal", axis: { title: xLabel, labelAngle: ax.xLabelAngle, tickCount: ax.xTickCount } },
      y: { field: "value", type: "quantitative", axis: { title: yLabel, tickCount: 5 } },
      color: { value: palette[0] },  // Explicitly use first color from palette
      tooltip: [
        { field: "label", type: "nominal" },
        { field: "value", type: "quantitative" }
      ]
    }
  };
}

function specFromComboTile(t, d){
  const combo = d.combo || {};
  const labels = combo.labels || [];
  const xLabel = combo.x_label || "";
  const series = Array.isArray(combo.series) ? combo.series : [];

  if(!labels.length || !series.length){
    return specFromSeriesTile(t, d);
  }

  // Build row records with fields v0..vN
  const rows = labels.map((lb, i) => {
    const r = { label: String(lb ?? "") };
    series.forEach((s, k) => { r["v"+k] = Number((s.values||[])[i] ?? 0); });
    return r;
  });

  // Get palette
  const palette = getPalette();
  
  // Determine if we need dual axis (check if series specify different axes or have different mark types)
  const needsDualAxis = series.length === 2 && 
    ((series[0].axis || "left").toLowerCase() !== (series[1].axis || "left").toLowerCase() ||
     (series[0].mark || "line") !== (series[1].mark || "line"));
  
  const layers = series.map((s, k) => {
    const mark = (s.mark || "line").toLowerCase();
    const axis = needsDualAxis && k === 1 ? "right" : "left";
    const title = s.title || `Series ${k+1}`;
    const color = palette[k % palette.length];

    // Different mark types - make visually distinct
    const mk = (mark === "bar")
      ? { type: "bar", cornerRadiusEnd: 4, opacity: 0.75 }
      : { type: "line", point: { filled: true, size: 80 }, strokeWidth: 3 };

    return {
      mark: mk,
      encoding: {
        x: { 
          field: "label", 
          type: "ordinal", 
          axis: { 
            title: k === 0 ? xLabel : "", 
            labelAngle: 0, 
            tickCount: 6 
          } 
        },
        y: { 
          field: "v" + k, 
          type: "quantitative", 
          axis: needsDualAxis ? { 
            title: title, 
            orient: axis, 
            tickCount: 5,
            titleColor: color,
            titleFontWeight: "bold",
            titleFontSize: 12,
            labelColor: color,
            labelFontWeight: "bold",
            grid: k === 0,
            gridOpacity: 0.2
          } : {
            title: k === 0 ? "Value (Â£)" : "",
            orient: "left",
            tickCount: 5,
            grid: k === 0,
            gridOpacity: 0.2
          },
          scale: needsDualAxis ? { zero: false } : undefined
        },
        color: {
          datum: title,
          scale: { 
            domain: series.map(s => s.title || `Series ${series.indexOf(s)+1}`),
            range: series.map((s,i) => palette[i % palette.length])
          },
          legend: {
            title: null,
            orient: "top",
            direction: "horizontal",
            labelFontSize: 11,
            symbolSize: 100,
            symbolStrokeWidth: 2
          }
        },
        tooltip: [
          { field: "label", type: "nominal", title: xLabel },
          { field: "v" + k, type: "quantitative", title: title, format: ",.0f" }
        ]
      }
    };
  });

  return {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    width: "container",
    height: "container",
    config: vegaBaseConfig(),
    data: { values: rows },
    resolve: needsDualAxis ? { scale: { y: "independent" } } : undefined,
    layer: layers
  };
}

function normType(t){
  return String(t || "")
    .toLowerCase()
    .trim()
    .replace(/\s+/g, "_")
    .replace(/[()]/g, "");
}

function isChartType(type){
  const tt = normType(type);
  return new Set([
    "bar","line","pie","combo",
    "scatter","bubble",
    "stacked_bar","multi_series_bar","multi_series_line",
    "histogram","area","stacked_area",
    "heatmap","boxplot",
    "waterfall","gauge"
  ]).has(tt);
}

// ---------- payload normalisers ----------

// Existing: {series:{labels,values}} -> rows [{label,value}]
function seriesToRows(labels, values){
  const rows = [];
  for(let i=0;i<Math.max(labels?.length||0, values?.length||0);i++){
    rows.push({ label: String(labels?.[i] ?? ""), value: Number(values?.[i] ?? 0) });
  }
  return rows;
}

// Multi-series payload:
// d.multi_series = { labels:[...], series:[{name, values:[...]}] }
// -> long rows [{label, series, value}]
function multiSeriesToRows(ms){
  const labels = ms?.labels || [];
  const series = Array.isArray(ms?.series) ? ms.series : [];
  const rows = [];
  series.forEach(s => {
    const name = String(s?.name ?? s?.title ?? "Series");
    const vals = Array.isArray(s?.values) ? s.values : [];
    labels.forEach((lb, i) => {
      rows.push({ label: String(lb ?? ""), series: name, value: Number(vals[i] ?? 0) });
    });
  });
  return rows;
}

// Stacked payload:
// d.stacked = { labels:[...], series:[{name, values:[...]}] }
// -> long rows same as multi series (stacked uses series as color)
function stackedToRows(st){
  return multiSeriesToRows(st);
}

// Scatter payload:
// d.scatter = { points:[{x,y, label?, series?}] }
function scatterToRows(sc){
  const pts = Array.isArray(sc?.points) ? sc.points : [];
  return pts.map(p => ({
    x: Number(p?.x ?? 0),
    y: Number(p?.y ?? 0),
    label: p?.label != null ? String(p.label) : "",
    series: p?.series != null ? String(p.series) : ""
  }));
}

// Bubble payload:
// d.bubble = { points:[{x,y,size,label?,series?}] }
function bubbleToRows(bb){
  const pts = Array.isArray(bb?.points) ? bb.points : [];
  return pts.map(p => ({
    x: Number(p?.x ?? 0),
    y: Number(p?.y ?? 0),
    size: Number(p?.size ?? 0),
    label: p?.label != null ? String(p.label) : "",
    series: p?.series != null ? String(p.series) : ""
  }));
}

// Heatmap payload:
// d.heatmap = { rows:[{x,y,value}] }
function heatmapToRows(hm){
  const rows = Array.isArray(hm?.rows) ? hm.rows : [];
  return rows.map(r => ({ x: String(r?.x ?? ""), y: String(r?.y ?? ""), value: Number(r?.value ?? 0) }));
}

// Boxplot payload:
// d.boxplot = { rows:[{category,value}] }  (raw points; Vega will compute boxes)
function boxplotToRows(bp){
  const rows = Array.isArray(bp?.rows) ? bp.rows : [];
  return rows.map(r => ({ category: String(r?.category ?? ""), value: Number(r?.value ?? 0) }));
}

// Waterfall payload:
// d.waterfall = { steps:[{label, value, kind:'start'|'delta'|'end'}] }
// value for delta is +/-, start/end are absolute
function waterfallToRows(wf){
  const steps = Array.isArray(wf?.steps) ? wf.steps : [];
  return steps.map(s => ({
    label: String(s?.label ?? ""),
    value: Number(s?.value ?? 0),
    kind: String(s?.kind ?? "delta") // start|delta|end
  }));
}

// Gauge payload:
// d.gauge = { value, min?, max?, label? }
function gaugeToRows(g){
  const v = Number(g?.value ?? 0);
  const min = Number(g?.min ?? 0);
  const max = Number(g?.max ?? 100);
  const clamped = Math.max(min, Math.min(v, max));
  const pct = (max === min) ? 0 : ((clamped - min) / (max - min)) * 100;
  return [{ value: clamped, min, max, pct }];
}

// Histogram payload options:
// (A) d.histogram.values = [numbers...] (preferred; Vega bins)
// (B) d.series.values already counts per label (fallback)
function histogramValues(d){
  const vals = d?.histogram?.values;
  if(Array.isArray(vals) && vals.length) return vals.map(x => Number(x)).filter(x => Number.isFinite(x));
  return null;
}

// ---------- SPEC BUILDERS ----------

function specBase(values){
  return {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    data: { values },
    width: "container",
    height: "container",
    config: vegaBaseConfig()
  };
}

// keep your existing ones
// - specFromSeriesTile(t,d)
// - specFromComboTile(t,d)

function specScatter(t, d){
  const sc = d.scatter || d;
  const rows = scatterToRows(sc);
  const xTitle = sc?.x_label || "X";
  const yTitle = sc?.y_label || "Y";
  const hasSeries = rows.some(r => r.series);

  return {
    ...specBase(rows),
    mark: { type: "point", filled: true, size: 60 },
    encoding: {
      x: { field:"x", type:"quantitative", axis:{ title:xTitle } },
      y: { field:"y", type:"quantitative", axis:{ title:yTitle } },
      color: hasSeries ? { field:"series", type:"nominal", legend:{ title:null } } : undefined,
      tooltip: [
        { field:"x", type:"quantitative", title:xTitle },
        { field:"y", type:"quantitative", title:yTitle },
        ...(hasSeries ? [{ field:"series", type:"nominal" }] : []),
        { field:"label", type:"nominal" }
      ].filter(Boolean)
    }
  };
}

function specBubble(t, d){
  const bb = d.bubble || d;
  const rows = bubbleToRows(bb);
  const xTitle = bb?.x_label || "X";
  const yTitle = bb?.y_label || "Y";
  const sTitle = bb?.size_label || "Size";
  const hasSeries = rows.some(r => r.series);

  return {
    ...specBase(rows),
    mark: { type:"circle", opacity: 0.65 },
    encoding: {
      x: { field:"x", type:"quantitative", axis:{ title:xTitle } },
      y: { field:"y", type:"quantitative", axis:{ title:yTitle } },
      size: { field:"size", type:"quantitative", legend:{ title:sTitle } },
      color: hasSeries ? { field:"series", type:"nominal", legend:{ title:null } } : undefined,
      tooltip: [
        { field:"x", type:"quantitative", title:xTitle },
        { field:"y", type:"quantitative", title:yTitle },
        { field:"size", type:"quantitative", title:sTitle },
        ...(hasSeries ? [{ field:"series", type:"nominal" }] : []),
        { field:"label", type:"nominal" }
      ].filter(Boolean)
    }
  };
}

function specMultiSeriesLine(t, d){
  const ms = d.multi_series || d.multi_series_line || d;
  const rows = multiSeriesToRows(ms);
  const xTitle = ms?.x_label || d.series?.x_label || "";
  let yTitle = ms?.y_label || d.series?.y_label || "Value";
  if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

  const palette = getPalette();

  return {
    ...specBase(rows),
    mark: { type:"line", point:{filled:true,size:50}, strokeWidth:2.5 },
    encoding: {
      x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle } },
      color: { 
        field:"series", 
        type:"nominal",
        scale: { range: palette },
        legend:{ title:null, orient:"top", direction:"horizontal", labelFontSize:11 }
      },
      tooltip: [
        { field:"label", type:"nominal" },
        { field:"series", type:"nominal" },
        { field:"value", type:"quantitative", format:",.0f" }
      ]
    }
  };
}

function specMultiSeriesBar(t, d){
  const ms = d.multi_series || d.multi_series_bar || d;
  const rows = multiSeriesToRows(ms);
  const xTitle = ms?.x_label || d.series?.x_label || "";
  let yTitle = ms?.y_label || d.series?.y_label || "Value";
  if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

  const palette = getPalette();

  return {
    ...specBase(rows),
    mark: { type:"bar", cornerRadiusEnd:4 },
    encoding: {
      x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle } },
      color: { 
        field:"series", 
        type:"nominal",
        scale: { range: palette },
        legend:{ title:null, orient:"top", direction:"horizontal", labelFontSize:11 }
      },
      xOffset: { field:"series" },
      tooltip: [
        { field:"label", type:"nominal" },
        { field:"series", type:"nominal" },
        { field:"value", type:"quantitative", format:",.0f" }
      ]
    }
  };
}

function specStackedBar(t, d){
  const st = d.stacked || d.stacked_bar || d;
  const rows = stackedToRows(st);
  const xTitle = st?.x_label || "";
  let yTitle = st?.y_label || "Value";
  if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

  return {
    ...specBase(rows),
    mark: { type:"bar", cornerRadiusEnd:2 },
    encoding: {
      x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle }, stack:"zero" },
      color: { field:"series", type:"nominal", legend:{ title:null } },
      tooltip: [
        { field:"label", type:"nominal" },
        { field:"series", type:"nominal" },
        { field:"value", type:"quantitative" }
      ]
    }
  };
}

function specArea(t, d){
  // area is basically line with area mark
  const typ = normType(t.type);
  const isStacked = (typ === "stacked_area");

  if(isStacked){
    const st = d.stacked || d.stacked_area || d;
    const rows = stackedToRows(st);
    const xTitle = st?.x_label || "";
    let yTitle = st?.y_label || "Value";
    if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

    return {
      ...specBase(rows),
      mark: { type:"area" },
      encoding: {
        x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
        y: { field:"value", type:"quantitative", axis:{ title:yTitle }, stack:"zero" },
        color: { field:"series", type:"nominal", legend:{ title:null } },
        tooltip: [
          { field:"label", type:"nominal" },
          { field:"series", type:"nominal" },
          { field:"value", type:"quantitative" }
        ]
      }
    };
  }

  // plain area from existing d.series
  const labels = d.series?.labels || [];
  const values = d.series?.values || [];
  const rows = seriesToRows(labels, values);
  const xTitle = d.series?.x_label || "";
  let yTitle = d.series?.y_label || "Value";
  if(/amount|revenue|sales|profit|turnover/i.test(yTitle)) yTitle = `${yTitle} (${getCurrency()})`;

  return {
    ...specBase(rows),
    mark: { type:"area" },
    encoding: {
      x: { field:"label", type:"ordinal", axis:{ title:xTitle, labelAngle:0, tickCount:6 } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle } },
      tooltip: [
        { field:"label", type:"nominal" },
        { field:"value", type:"quantitative" }
      ]
    }
  };
}

function specHeatmap(t, d){
  const hm = d.heatmap || d;
  const rows = heatmapToRows(hm);
  const xTitle = hm?.x_label || "X";
  const yTitle = hm?.y_label || "Y";
  const vTitle = hm?.value_label || "Value";

  return {
    ...specBase(rows),
    mark: { type:"rect" },
    encoding: {
      x: { field:"x", type:"nominal", axis:{ title:xTitle, labelAngle:0 } },
      y: { field:"y", type:"nominal", axis:{ title:yTitle } },
      color: { field:"value", type:"quantitative", legend:{ title:vTitle } },
      tooltip: [
        { field:"x", type:"nominal", title:xTitle },
        { field:"y", type:"nominal", title:yTitle },
        { field:"value", type:"quantitative", title:vTitle }
      ]
    }
  };
}

function specBoxplot(t, d){
  const bp = d.boxplot || d;
  const rows = boxplotToRows(bp);
  const xTitle = bp?.x_label || "Category";
  const yTitle = bp?.y_label || "Value";

  return {
    ...specBase(rows),
    mark: { type:"boxplot" },
    encoding: {
      x: { field:"category", type:"nominal", axis:{ title:xTitle } },
      y: { field:"value", type:"quantitative", axis:{ title:yTitle } },
      tooltip: [
        { field:"category", type:"nominal" },
        { field:"value", type:"quantitative" }
      ]
    }
  };
}

function specHistogram(t, d){
  const vals = histogramValues(d);
  if(vals && vals.length){
    const rows = vals.map(v => ({ value: v }));
    const xTitle = d?.histogram?.x_label || "Value";
    const yTitle = d?.histogram?.y_label || "Count";

    return {
      ...specBase(rows),
      transform: [{ bin: true, field: "value", as: ["bin_start","bin_end"] }],
      mark: { type:"bar", cornerRadiusEnd:4 },
      encoding: {
        x: { field:"bin_start", type:"quantitative", axis:{ title:xTitle } },
        x2:{ field:"bin_end" },
        y: { aggregate:"count", type:"quantitative", axis:{ title:yTitle } },
        tooltip: [
          { field:"bin_start", type:"quantitative", title:"From" },
          { field:"bin_end", type:"quantitative", title:"To" },
          { aggregate:"count", type:"quantitative", title:"Count" }
        ]
      }
    };
  }

  // fallback: if backend gave a normal series (labels are bins already)
  return specFromSeriesTile({ ...t, type:"bar" }, d);
}

function specWaterfall(t, d){
  const wf = d.waterfall || d;
  const rows = waterfallToRows(wf);

  // Vega-lite waterfall approximation:
  // build running total in JS (simpler + robust)
  let running = 0;
  const out = rows.map(r => {
    const kind = r.kind;
    let start = 0, end = 0;

    if(kind === "start"){
      running = r.value;
      start = 0;
      end = running;
    } else if(kind === "end"){
      start = 0;
      end = r.value;
      running = r.value;
    } else {
      // delta
      start = running;
      running = running + r.value;
      end = running;
    }

    return {
      label: r.label,
      start,
      end,
      delta: r.value,
      dir: (r.value >= 0 ? "up" : "down"),
      kind
    };
  });

  const yTitle = wf?.y_label || "Value";

  return {
    ...specBase(out),
    layer: [
      {
        mark: { type:"bar", cornerRadiusEnd:3 },
        encoding: {
          x: { field:"label", type:"ordinal", axis:{ title:null, labelAngle:0 } },
          y: { field:"start", type:"quantitative", axis:{ title:yTitle } },
          y2:{ field:"end" },
          color: { field:"dir", type:"nominal", legend:null }
        }
      },
      {
        mark: { type:"rule" },
        encoding: {
          x: { field:"label", type:"ordinal" },
          y: { field:"end", type:"quantitative" }
        }
      }
    ]
  };
}

function specGauge(t, d){
  const g = d.gauge || d;
  const rows = gaugeToRows(g);
  const label = g?.label || t.title || "";

  // Semi-circle gauge using arc + text
  return {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    width: "container",
    height: "container",
    config: vegaBaseConfig(),
    layer: [
      // background arc
      {
        data: { values: [{ v: 100 }] },
        mark: { type:"arc", innerRadius: 70, outerRadius: 95, startAngle: -Math.PI, endAngle: 0 },
        encoding: { theta: { field:"v", type:"quantitative" } }
      },
      // foreground arc
      {
        data: { values: [{ v: rows[0].pct }] },
        mark: { type:"arc", innerRadius: 70, outerRadius: 95, startAngle: -Math.PI, endAngle: -Math.PI + (rows[0].pct/100)*Math.PI },
        encoding: { theta: { field:"v", type:"quantitative" } }
      },
      // value text
      {
        data: { values: [{ txt: `${rows[0].pct.toFixed(0)}%`, sub: label }] },
        mark: { type:"text", dy: -5, fontSize: 22, fontWeight: 800 },
        encoding: { text: { field:"txt" } }
      },
      {
        data: { values: [{ sub: label }] },
        mark: { type:"text", dy: 18, fontSize: 11 },
        encoding: { text: { field:"sub" } }
      }
    ]
  };
}

function specFromTile(t, d){
  const tt = normType(t?.type);

  // Auto-detect multi-series from data structure
  if(d.multi_series && !tt.includes("multi_series")){
    // Backend sent multi_series data but type is just "line" or "bar"
    if(tt === "line" || tt === "multi_line"){
      return specMultiSeriesLine(t, d);
    }
    if(tt === "bar"){
      return specMultiSeriesBar(t, d);
    }
  }

  // existing payloads
  if(tt === "combo") return specFromComboTile(t, d);
  if(tt === "pie" || tt === "bar" || tt === "line") return specFromSeriesTile(t, d);

  // new types
  if(tt === "area" || tt === "stacked_area") return specArea(t, d);
  if(tt === "scatter") return specScatter(t, d);
  if(tt === "bubble") return specBubble(t, d);
  if(tt === "multi_series_line") return specMultiSeriesLine(t, d);
  if(tt === "multi_series_bar") return specMultiSeriesBar(t, d);
  if(tt === "stacked_bar") return specStackedBar(t, d);
  if(tt === "heatmap") return specHeatmap(t, d);
  if(tt === "boxplot") return specBoxplot(t, d);
  if(tt === "histogram") return specHistogram(t, d);
  if(tt === "waterfall") return specWaterfall(t, d);
  if(tt === "gauge") return specGauge(t, d);

  // fallback
  return specFromSeriesTile({ ...t, type:"bar" }, d);
}

async function createSession(){
  let r = await fetch(`${ORCH}/session`, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({prompt:""})
  });
  if(r.status === 422){
    r = await fetch(`${ORCH}/session`, { method:"POST" });
  }
  const j = await r.json();
  const newSid = j.sid || j.session_id;
  cookieSet("mr_sid", newSid);
  sid = newSid;
  $("sidBadge").textContent = sid;
  return sid;
}

async function ensureSession(){
  if(readQuery("new")==="1"){ cookieDel("mr_sid"); }
  const urlSid = (readQuery("sid")||"").trim();
  const ckSid = (cookieGet("mr_sid")||"").trim();
  if(urlSid){
    sid = urlSid;
    cookieSet("mr_sid", sid);
    $("sidBadge").textContent = sid;
    return sid;
  }
  if(ckSid){
    sid = ckSid;
    $("sidBadge").textContent = sid;
    return sid;
  }
  return await createSession();
}

/* ---------- Chat Interface Functions ---------- */
// Persistent message storage
let chatMessageHistory = [];
let thinkingInterval = null;
let currentThinkingElement = null;

function addThinkingPlaceholder() {
  const chatMessages = document.getElementById("chatMessages");
  if (!chatMessages) return null;
  
  // Simple plain text placeholder like reference
  const placeholder = document.createElement("div");
  placeholder.style.cssText = `
    margin: 0.3em 0 !important;
    font-style: italic !important;
    opacity: 0.7 !important;
    color: #666 !important;
    font-size: 13px !important;
  `;
  placeholder.textContent = "Thinking";
  
  chatMessages.appendChild(placeholder);
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // Animate dots only (no pulse)
  let dots = 0;
  thinkingInterval = setInterval(() => {
    dots = (dots + 1) % 4;
    placeholder.textContent = "Thinking" + ".".repeat(dots);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }, 500);
  
  currentThinkingElement = placeholder;
  console.log("[Chat] Added thinking placeholder");
  return placeholder;
}

function removeThinkingPlaceholder() {
  if (thinkingInterval) {
    clearInterval(thinkingInterval);
    thinkingInterval = null;
  }
  if (currentThinkingElement) {
    currentThinkingElement.remove();
    currentThinkingElement = null;
    console.log("[Chat] Removed thinking placeholder");
  }
}

function addChatMessage(text, isUser = false, animate = false) {
  console.log("[Chat] Adding message:", text.substring(0, 50), "isUser:", isUser, "animate:", animate);
  
  // Store in history
  chatMessageHistory.push({ text, isUser, timestamp: Date.now() });
  
  // Try multiple ways to get the element
  let chatMessages = document.getElementById("chatMessages");
  
  if (!chatMessages) {
    console.error("[Chat] chatMessages element not found via getElementById!");
    console.error("[Chat] Trying querySelector...");
    chatMessages = document.querySelector("#chatMessages");
  }
  
  if (!chatMessages) {
    console.error("[Chat] chatMessages element not found via querySelector either!");
    console.error("[Chat] Available elements with 'chat' in ID:");
    const allElements = document.querySelectorAll('[id*="chat"]');
    allElements.forEach(el => console.log("  -", el.id, el.tagName));
    
    // As a last resort, try to find the chat container and look inside
    const container = document.querySelector(".chat-container");
    if (container) {
      console.log("[Chat] Found chat-container, looking for chat-messages inside...");
      chatMessages = container.querySelector(".chat-messages");
      if (chatMessages) {
        console.log("[Chat] Found chat-messages via class selector!");
      }
    }
    
    if (!chatMessages) {
      console.error("[Chat] CRITICAL: Cannot find chat messages container anywhere!");
      console.error("[Chat] Message stored in history but couldn't be displayed");
      console.error("[Chat] Will attempt to display when container is found");
      return;
    }
  }
  
  console.log("[Chat] Successfully found chatMessages element:", chatMessages);
  
  const messageDiv = document.createElement("div");
  messageDiv.className = `chat-message chat-message-${isUser ? 'user' : 'ai'}`;
  // Force inline styles
  messageDiv.style.cssText = `
    display: flex !important;
    flex-direction: column !important;
    margin: 0.5em 0 !important;
    align-items: ${isUser ? 'flex-end' : 'flex-start'} !important;
  `;
  
  const label = document.createElement("div");
  label.className = "chat-bubble-label";
  label.textContent = isUser ? "You" : "AI Assistant";
  label.style.cssText = `
    font-size: 10px !important;
    font-weight: 600 !important;
    text-transform: uppercase !important;
    letter-spacing: 0.05em !important;
    margin-bottom: 4px !important;
    opacity: 0.7 !important;
    color: #690697 !important;
  `;
  
  const bubble = document.createElement("div");
  bubble.className = "chat-bubble";
  bubble.style.cssText = `
    max-width: 75% !important;
    padding: 12px 16px !important;
    border-radius: 12px !important;
    line-height: 1.5 !important;
    font-size: 13px !important;
    word-wrap: break-word !important;
    white-space: pre-wrap !important;
    background: ${isUser ? '#690697' : '#e2e2e2'} !important;
    color: ${isUser ? 'white' : 'black'} !important;
    box-shadow: ${isUser ? '0 4px 12px rgba(105, 6, 151, 0.25)' : '0 2px 8px rgba(0, 0, 0, 0.05)'} !important;
  `;
  
  messageDiv.appendChild(label);
  messageDiv.appendChild(bubble);
  chatMessages.appendChild(messageDiv);
  
  // Typing animation for AI responses
  if (animate && !isUser) {
    bubble.textContent = '';
    let i = 0;
    const speed = 15; // milliseconds per character
    
    function typeChar() {
      if (i < text.length) {
        bubble.textContent += text.charAt(i);
        i++;
        setTimeout(typeChar, speed);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
    }
    
    typeChar();
  } else {
    bubble.textContent = text;
  }
  
  console.log("[Chat] Message div appended. Total messages:", chatMessages.children.length);
  
  // Auto-scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

function restoreChatMessages() {
  console.log("[Chat] Restoring", chatMessageHistory.length, "messages from history");
  const chatMessages = document.getElementById("chatMessages");
  if (!chatMessages) {
    console.error("[Chat] Cannot restore - chatMessages element not found");
    return;
  }
  
  // Clear existing messages
  chatMessages.innerHTML = '';
  
  // Re-add all messages from history
  chatMessageHistory.forEach(msg => {
    const messageDiv = document.createElement("div");
    messageDiv.className = `chat-message chat-message-${msg.isUser ? 'user' : 'ai'}`;
    messageDiv.style.cssText = `
      display: flex !important;
      flex-direction: column !important;
      margin: 0.5em 0 !important;
      align-items: ${msg.isUser ? 'flex-end' : 'flex-start'} !important;
    `;
    
    const label = document.createElement("div");
    label.className = "chat-bubble-label";
    label.textContent = msg.isUser ? "You" : "AI Assistant";
    label.style.cssText = `
      font-size: 10px !important;
      font-weight: 600 !important;
      text-transform: uppercase !important;
      letter-spacing: 0.05em !important;
      margin-bottom: 4px !important;
      opacity: 0.7 !important;
      color: #690697 !important;
    `;
    
    const bubble = document.createElement("div");
    bubble.className = "chat-bubble";
    bubble.textContent = msg.text;
    bubble.style.cssText = `
      max-width: 75% !important;
      padding: 12px 16px !important;
      border-radius: 12px !important;
      line-height: 1.5 !important;
      font-size: 13px !important;
      word-wrap: break-word !important;
      white-space: pre-wrap !important;
      background: ${msg.isUser ? '#690697' : '#e2e2e2'} !important;
      color: ${msg.isUser ? 'white' : 'black'} !important;
      box-shadow: ${msg.isUser ? '0 4px 12px rgba(105, 6, 151, 0.25)' : '0 2px 8px rgba(0, 0, 0, 0.05)'} !important;
    `;
    
    messageDiv.appendChild(label);
    messageDiv.appendChild(bubble);
    chatMessages.appendChild(messageDiv);
  });
  
  // Auto-scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
  console.log("[Chat] Restored", chatMessages.children.length, "messages");
}

function clearChatMessages() {
  const chatMessages = $("chatMessages");
  if (chatMessages) {
    chatMessages.innerHTML = "";
  }
  // Clear history
  chatMessageHistory = [];
  console.log("[Chat] Cleared all messages and history");
}

/* ---------- Field map ---------- */
function renderFieldMap(fields){
  $("fCount").textContent = fields.length;
  const body = $("fmBody");
  body.innerHTML = "";
  fields.forEach((f,i) => {
    const row = document.createElement("div"); row.className="fm-row";
    const cField = document.createElement("div"); cField.textContent = f.field ?? f.name ?? "";
    const cDType = document.createElement("div");
    const cAllowed = document.createElement("div");
    const cDesc = document.createElement("div");
    cDType.textContent = f.dtype ?? "";
    cAllowed.textContent = f.allowed ?? "";
    cDesc.textContent = f.description ?? "";
    [cDType,cAllowed,cDesc].forEach((cell, colIdx) => {
      cell.contentEditable = "true";
      cell.classList.add("fm-edit");
      cell.addEventListener("blur", () => {
        const val = cell.textContent.trim();
        if(colIdx===0) fields[i].dtype = val;
        if(colIdx===1) fields[i].allowed = val;
        if(colIdx===2) fields[i].description = val;
      });
    });
    row.append(cField,cDType,cAllowed,cDesc);
    body.appendChild(row);
  });
}

/* ---------- Questions ---------- */
function renderQuestions(qs){
  $("qCount").textContent = qs.length;
  const wrap = $("qWrap");
  wrap.innerHTML = "";
  if(!qs?.length){
    wrap.innerHTML = `<div class="muted">No questions returned.</div>`;
    return;
  }
  qs.forEach((q,idx) => {
    const text = (typeof q === "string" ? q : (q.text || ""));
    const card = document.createElement("div");
    card.className = "card";
    card.style.margin = "0 0 10px";
    card.style.boxShadow = "none";
    card.style.borderRadius = "12px";
    card.innerHTML = `
      <div style="font-size:12px;font-weight:600;margin-bottom:4px">Question ${idx+1}</div>
      <div style="margin:4px 0 8px;font-size:13px">${text}</div>
    `;
    const ta = document.createElement("textarea");
    ta.placeholder = "Your answer (optional)";
    ta.addEventListener("input", () => { answers[idx] = ta.value; });
    card.appendChild(ta);
    wrap.appendChild(card);
  });
}


async function renderVega(el, spec){
  if(typeof vegaEmbed !== "function"){
    el.textContent = "Chart library not loaded yet."; return;
  }
  if(spec && spec.data && spec.data.url) delete spec.data.url;

  // Merge palette from DSL theme into spec config
  var palette = null;
  try{ var pal = dsl && dsl.theme && dsl.theme.palette; if(Array.isArray(pal) && pal.length) palette = pal; }catch(e){}
  if(palette){
    spec.config = spec.config || {};
    spec.config.range = spec.config.range || {};
    spec.config.range.category = palette;
    spec.config.range.ordinal = palette;
  }

  el.innerHTML = "";
  try{
    var result = await vegaEmbed(el, spec, { actions:false, renderer:"svg" });
    el._vegaSpec = spec; el._vegaView = result.view;
    if(!el._resizeObs){
      var pending = null;
      el._resizeObs = new ResizeObserver(function(){
        clearTimeout(pending);
        pending = setTimeout(async function(){
          if(el._vegaSpec && el.offsetWidth > 0 && el.offsetHeight > 0){
            try{
              el.innerHTML = "";
              var r2 = await vegaEmbed(el, el._vegaSpec, { actions:false, renderer:"svg" });
              el._vegaView = r2.view;
            }catch(e2){}
          }
        }, 200);
      });
      el._resizeObs.observe(el);
    }
  }catch(e){
    console.error("Vega render error", e);
    el.textContent = "Could not render chart.";
  }
}

/* ---------- Simple auto-layout (12-col grid, row-by-row) ---------- */
function autoLayoutTiles(tiles) {
  const cols = 12;
  let cursorX = 0;
  let cursorY = 0;
  let rowH = 0;
  const out = {};

  tiles.forEach(t => {
    const id = t.id || Math.random().toString(36).slice(2);
    const w = Math.min(t.w || 3, cols);
    const h = Math.max(t.h || 2, 2);

    if (cursorX + w > cols) {
      cursorX = 0;
      cursorY += rowH || 2;
      rowH = 0;
    }

    out[id] = { x: cursorX, y: cursorY, w, h };
    cursorX += w;
    rowH = Math.max(rowH, h);
  });

  return out;
}

/* ---------- Preview + interactivity ---------- */
function renderPreviewPayload(tiles){
  const canvas = $("previewCanvas");
  canvas.innerHTML = "";
  if(!tiles?.length){
    const msg = document.createElement("div");
    msg.className = "preview-empty";
    msg.textContent = "No tiles in the design yet. Generate a dashboard first.";
    canvas.appendChild(msg);
    return;
  }
  function hasPos(t){
    return Number.isFinite(t.x) && Number.isFinite(t.y) && Number.isFinite(t.w) && Number.isFinite(t.h);
  }

  // ðŸ”§ If tile count changed (add/remove), reset cached layout so new tiles
  // donâ€™t stack underneath old ones.
  if (Object.keys(localLayout).length &&
      Object.keys(localLayout).length !== tiles.length) {
    localLayout = {};
  }

  const cols = 12;
  const rows = Math.max(1, ...tiles.map(t => (t.y || 0) + (t.h || 2)));
  const needsAuto = tiles.filter(t => !(Number.isFinite(t.x) && Number.isFinite(t.y) && Number.isFinite(t.w) && Number.isFinite(t.h)));
  const autoPos = autoLayoutTiles(needsAuto);

  tiles.forEach(t=>{
    const id = t.id || Math.random().toString(36).slice(2);

    const hasPos = Number.isFinite(t.x) && Number.isFinite(t.y) && Number.isFinite(t.w) && Number.isFinite(t.h);

    const base = { w: t.w || 3, h: t.h || 3, x: t.x || 0, y: t.y || 0 };
    const defaultPos = hasPos ? base : (autoPos[id] || base);
    const stored = localLayout[id] || {};

    const pos = {
      x: Math.min(stored.x ?? defaultPos.x, cols - 1),
      y: Math.min(stored.y ?? defaultPos.y, rows - 1),
      w: Math.min(stored.w ?? defaultPos.w, cols),
      h: Math.min(stored.h ?? defaultPos.h, rows),
    };

    const tile = document.createElement("div");
    tile.className = "tile";
    tile.dataset.id = id;

    tile.style.left   = `${(pos.x/cols)*100}%`;
    tile.style.top    = `${(pos.y/rows)*100}%`;
    tile.style.width  = `${(pos.w/cols)*100}%`;
    tile.style.height = `${(pos.h/rows)*100}%`;

    localLayout[id] = pos;

    // Remove button (Ã— with confirmation)
    const removeBtn = document.createElement("button");
    removeBtn.className = "tile-remove-btn";
    removeBtn.textContent = "\u00D7";
    removeBtn.title = "Remove chart";
    removeBtn.addEventListener("click", function(ev){
      ev.stopPropagation();
      var chartTitle = t.title || "this chart";
      if(confirm("Are you sure you want to remove \"" + chartTitle + "\"?")){
        removeTileFromDashboard(id, chartTitle);
      }
    });
    tile.appendChild(removeBtn);

    const th = document.createElement("div");
    th.className = "t-h";
    const titleSpan = document.createElement("span");
    titleSpan.textContent = t.title || (t.type||"").toUpperCase();
    const sizeSpan = document.createElement("span");
    sizeSpan.className = "muted";
    sizeSpan.textContent = `${pos.w}Ã—${pos.h}`;
    th.append(titleSpan,sizeSpan);

    const tb = document.createElement("div");
    tb.classList.remove("chart-body");
    tb.className = "t-b";
    const d = t.data || {};

    if (d.kpi) {
      tb.classList.add("kpi-body");
      const head = document.createElement("div");
      head.className = "kpi";

      // Prefer pretty string if the backend gives one
      let display = "";
      if (typeof d.kpi.pretty === "string" && d.kpi.pretty.trim()) {
        display = d.kpi.pretty.trim();
      } else {
        const raw = Number(d.kpi.value ?? 0);
        const prefix = d.kpi.prefix || "";
        const unit = d.kpi.unit || "";

        if (unit === "%") {
          // boolean-rate KPIs like Return Rate
          display = `${raw * 100 >= 1 ? raw.toFixed(2) : (raw * 100).toFixed(2)}%`;
        } else if (prefix) {
          display = `${prefix}${raw.toLocaleString()}`;
        } else {
          display = raw.toLocaleString();
        }
      }
      const pretty = d.kpi.pretty;
      if (pretty) {
        head.textContent = pretty;
      } else {
        head.textContent = display; // whatever you currently compute for numeric/currency
      }

      // Title is already shown in tile header â€” no duplicate label needed
      tb.appendChild(head);

      if (d.kpi.delta) {
        const pct = d.kpi.delta.pct;
        if (pct !== null && pct !== undefined) {
          const delta = document.createElement("div");
          const good = (pct || 0) >= 0;
          delta.className = "kpi-delta " + (good ? "" : "neg");

          const isRate = (d.kpi.unit === "%");
          delta.textContent = isRate
            ? `${good ? "â–²" : "â–¼"} ${Math.abs(pct).toFixed(2)}pp vs prior period`
            : `${good ? "â–²" : "â–¼"} ${pct.toFixed(1)}% vs prior period`;

          tb.appendChild(delta);
        }
      }
    }
    // --- NEW: render compiled vega-lite spec if present ---
    else if (t.vl_spec || d.vl_spec) {
      tb.classList.add("chart-body");
      const box = document.createElement("div");
      box.className = "chart";
      box.style.width = "100%";
      box.style.height = "100%";
      tb.appendChild(box);

      const spec = (d.vl_spec || t.vl_spec);
      renderVega(box, spec);
    }
    else if(d.combo){
      tb.classList.add("chart-body");

      const box = document.createElement("div");
      box.className = "chart";
      box.style.width = "100%";
      box.style.height = "100%";
      tb.appendChild(box);

      const spec = specFromComboTile(t, d);
      renderVega(box, spec);
    }

    else if (isChartType(t.type) && (d.combo || d.series || d.multi_series || d.stacked || d.scatter || d.bubble || d.heatmap || d.boxplot || d.histogram || d.waterfall || d.gauge)) {
      tb.classList.add("chart-body");
      const box = document.createElement("div");
      box.className = "chart";
      box.style.width = "100%";
      box.style.height = "100%";
      tb.appendChild(box);

      const spec = specFromTile(t, d);
      renderVega(box, spec);
    }
    else if(d.table){
      const wrap = document.createElement("div");
      wrap.className = "tablewrap";
      const tcols = d.table.columns || [];
      const rowsArr = d.table.rows || [];
      let html = "<table><thead><tr>" + tcols.map(c=>`<th>${c}</th>`).join("") + "</tr></thead><tbody>";
      rowsArr.forEach(r=>{
        html += "<tr>" + r.map(v=>`<td>${v ?? ""}</td>`).join("") + "</tr>";
      });
      html += "</tbody></table>";
      wrap.innerHTML = html;
      tb.appendChild(wrap);
    } else {
      tb.textContent = "No data.";
    }

    const handle = document.createElement("div");
    handle.className = "handle";
    tile.append(th,tb,handle);
    canvas.appendChild(tile);

    // drag / resize
    let startX=0,startY=0,startL=0,startT=0,startW=0,startH=0, dragging=false, resizing=false;

    function bringToFront(el){
      canvas.querySelectorAll(".tile").forEach(function(t){ t.style.zIndex = "1"; });
      el.style.zIndex = "10";
    }

    th.addEventListener("mousedown", (e)=>{
      dragging=true;
      bringToFront(tile);
      startX=e.clientX; startY=e.clientY;
      const r=tile.getBoundingClientRect(), c=canvas.getBoundingClientRect();
      startL=r.left-c.left; startT=r.top-c.top; startW=r.width; startH=r.height;
      e.preventDefault();
    });
    handle.addEventListener("mousedown", (e)=>{
      resizing=true;
      bringToFront(tile);
      startX=e.clientX; startY=e.clientY;
      const r=tile.getBoundingClientRect(), c=canvas.getBoundingClientRect();
      startL=r.left-c.left; startT=r.top-c.top; startW=r.width; startH=r.height;
      e.preventDefault();
    });

    window.addEventListener("mousemove", (e)=>{
      if(!dragging && !resizing) return;
      const c=canvas.getBoundingClientRect();
      let dx=e.clientX-startX, dy=e.clientY-startY;
      let nl=startL, nt=startT, nw=startW, nh=startH;
      if(dragging){
        nl = Math.max(0, Math.min(startL+dx, c.width-40));
        nt = Math.max(0, Math.min(startT+dy, c.height-40));
      }
      if(resizing){
        nw = Math.max(120, startW+dx);
        nh = Math.max(120, startH+dy);
      }
      let gx = Math.round((nl / c.width) * cols);
      let gy = Math.round((nt / c.height) * rows);
      gx = Math.max(0, Math.min(gx, cols - 1));
      gy = Math.max(0, Math.min(gy, rows - 1));

      let gw = Math.max(2, Math.round((nw / c.width) * cols));
      let gh = Math.max(2, Math.round((nh / c.height) * rows));
      gw = Math.min(gw, cols - gx);
      gh = Math.min(gh, rows - gy);
      tile.style.left = `${(gx/cols)*100}%`;
      tile.style.top  = `${(gy/rows)*100}%`;
      tile.style.width= `${(gw/cols)*100}%`;
      tile.style.height=`${(gh/rows)*100}%`;
      localLayout[id] = {x:gx,y:gy,w:gw,h:gh};
    });
    window.addEventListener("mouseup", ()=>{ dragging=false; resizing=false; });
  });
}

/* ---------- Fetch preview tiles (keep dsl for theme) ---------- */
function _showEmptyDateOverlay(show){
  const gridEl = document.querySelector(".grid-stack");
  if(!gridEl) return;
  let overlay = document.getElementById("emptyDateOverlay");
  if(show){
    if(!overlay){
      overlay = document.createElement("div");
      overlay.id = "emptyDateOverlay";
      overlay.style.cssText = "position:absolute;top:0;left:0;right:0;bottom:0;z-index:10;"
        + "display:flex;align-items:center;justify-content:center;flex-direction:column;"
        + "background:rgba(255,255,255,0.92);border-radius:12px;pointer-events:none;";
      overlay.innerHTML = '<div style="text-align:center;padding:40px">'
        + '<div style="font-size:40px;margin-bottom:12px">ðŸ“…</div>'
        + '<div style="font-size:18px;font-weight:600;color:#374151;margin-bottom:8px">No data in selected date range</div>'
        + '<div style="font-size:14px;color:#6b7280">Try adjusting the date filters or click <b>Clear filters</b> to view all data.</div>'
        + '</div>';
      gridEl.style.position = "relative";
      gridEl.appendChild(overlay);
    }
    overlay.style.display = "flex";
  } else {
    if(overlay) overlay.style.display = "none";
  }
}

async function refreshPreview(){
  if(!sid) return;
  const filterStatusEl = $("filterStatus");
  try{
    // Show loading state near the filter buttons
    if(filterStatusEl) {
      filterStatusEl.textContent = "Updating dashboard";
      filterStatusEl.style.color = "#6b7280";
      // Animate the dots
      let dotCount = 0;
      filterStatusEl._interval = setInterval(() => {
        dotCount = (dotCount + 1) % 4;
        filterStatusEl.textContent = "Updating dashboard" + ".".repeat(dotCount);
      }, 400);
    }
    const dashGrid = document.querySelector(".grid-stack");
    if(dashGrid) dashGrid.style.opacity = "0.5";

    const startVal = $("filterStart").value || null;
    const endVal   = $("filterEnd").value || null;
    const body = {
      filters: {
        date_range: (startVal || endVal) ? { start: startVal, end: endVal } : null,
        categories: currentFilters
      }
    };
    const r = await fetch(`${ORCH}/preview/${encodeURIComponent(sid)}`, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    if(r.ok){
      const j = await r.json();
      if(j.dsl) dsl = j.dsl;
      if(Array.isArray(j.tiles)){
        // Handle empty date range: show overlay instead of all-time data
        if(j.filtered_empty || j.warn === "date_range_out_of_bounds"){
          // Don't render any tile data â€” show an empty state overlay
          _showEmptyDateOverlay(true);
          if(filterStatusEl){
            filterStatusEl.textContent = "âš  No data in selected date range";
            filterStatusEl.style.color = "#b45309";
          }
        } else {
          _showEmptyDateOverlay(false);
          renderPreviewPayload(j.tiles);
          if(filterStatusEl) filterStatusEl.textContent = "";
        }
        return;
      }
    }
  }catch(e){
    console.debug("Preview refresh error", e);
  }finally{
    const dashGrid = document.querySelector(".grid-stack");
    if(dashGrid) dashGrid.style.opacity = "1";
    if(filterStatusEl && filterStatusEl._interval) {
      clearInterval(filterStatusEl._interval);
      filterStatusEl._interval = null;
    }
    // Only clear status text if it's not showing a warning (warnings persist)
    if(filterStatusEl && !filterStatusEl.textContent.startsWith("âš ")) {
      filterStatusEl.textContent = "";
    }
  }
  document.body.classList.toggle("dark", (dsl?.theme?.mode || "") === "dark");
  const tiles = (dsl?.pages?.[0]?.tiles||[]).map(t=>({...t, data:null}));
  
  renderPreviewPayload(tiles);
}

/* ---------- Date presets ---------- */
function formatDate(d){
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,"0");
  const day = String(d.getDate()).padStart(2,"0");
  return `${y}-${m}-${day}`;
}
function setQuickRange(mode){
  const now = new Date();
  let start, end;
  if(mode==="YTD"){
    start = new Date(now.getFullYear(),0,1);
    end = now;
  } else if(mode==="LAST_YEAR"){
    start = new Date(now.getFullYear()-1,0,1);
    end = new Date(now.getFullYear()-1,11,31);
  } else if(mode==="THIS_MONTH"){
    start = new Date(now.getFullYear(), now.getMonth(), 1);
    end = now;
  } else if(mode==="LAST_MONTH"){
    const m0 = now.getMonth()-1;
    const y0 = m0 < 0 ? now.getFullYear()-1 : now.getFullYear();
    const m = (m0+12)%12;
    start = new Date(y0, m, 1);
    end = new Date(y0, m+1, 0);
  }
  if(start && end){
    $("filterStart").value = formatDate(start);
    $("filterEnd").value = formatDate(end);
    refreshPreview();
  }
}

/* ---------- Wires ---------- */
async function onNewSession(){
  try{
    setBusy($("newSession"), true, "Startingâ€¦");
    cookieDel("mr_sid");
    await createSession();
    setMsg("aMsg","New session started.","ok");
  }catch(e){
    console.error(e);
    setMsg("aMsg","Could not start a new session.","err");
  }finally{
    setBusy($("newSession"), false);
  }
}

async function onProfile(){
  const btn = $("start");
  setBusy(btn,true,"Profilingâ€¦");
  setMsg("aMsg","");
  try{
    await ensureSession();
    const f = $("file").files[0];
    const prompt = ($("prompt").value||"").toString();

    const GCS_THRESHOLD = 20 * 1024 * 1024; // 20MB
    const CHUNK_SIZE = 10 * 1024 * 1024;    // 10MB per chunk

    let data;
    if(f && f.size > GCS_THRESHOLD){
      const sizeMB = (f.size/1024/1024).toFixed(1);
      const totalChunks = Math.ceil(f.size / CHUNK_SIZE);

      // Step 1: Tell backend we're starting a chunked upload
      setMsg("aMsg",`Preparing upload (${sizeMB} MB, ${totalChunks} chunks)â€¦`,"");
      const startResp = await fetch(`${ORCH}/upload-start/${encodeURIComponent(sid)}`, {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({ filename: f.name, total_size: f.size })
      });
      const startData = await startResp.json();
      if(!startData.ok) throw new Error(startData.error || "Could not start upload");
      const gcsKey = startData.gcs_key;

      // Step 2: Send file in chunks
      let lastResult = null;
      for(let i = 0; i < totalChunks; i++){
        const start = i * CHUNK_SIZE;
        const end = Math.min(start + CHUNK_SIZE, f.size);
        const chunk = f.slice(start, end);
        const isLast = (i === totalChunks - 1);

        const pct = Math.round(end / f.size * 100);
        const uploadedMB = (end/1024/1024).toFixed(1);
        setMsg("aMsg", `Uploadingâ€¦ ${uploadedMB}/${sizeMB} MB (${pct}%) â€” chunk ${i+1}/${totalChunks}`, "");

        const chunkResp = await fetch(
          `${ORCH}/upload-chunk/${encodeURIComponent(sid)}?index=${i}&last=${isLast}`,
          { method:"POST", body: chunk }
        );
        const chunkData = await chunkResp.json();
        if(!chunkData.ok) throw new Error(chunkData.error || `Chunk ${i} upload failed`);
        if(isLast) lastResult = chunkData;
      }

      // Step 3: Tell backend to profile from GCS
      setMsg("aMsg","Upload complete. Profiling datasetâ€¦","");
      const r = await fetch(`${ORCH}/profile-gcs/${encodeURIComponent(sid)}`, {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({ gcs_key: gcsKey, prompt: prompt })
      });
      const text = await r.text();
      try{ data = JSON.parse(text||"{}"); }catch(e){ data={}; }
      if(!r.ok) throw new Error(data?.error || text || `HTTP ${r.status}`);
    } else {
      // Small file: direct upload via FormData (original path)
      const fd = new FormData();
      fd.append("prompt", prompt);
      if(f) fd.append("file", f);
      const r = await fetch(`${ORCH}/profile/${encodeURIComponent(sid)}`, { method:"POST", body: fd });
      const text = await r.text();
      try{ data = JSON.parse(text||"{}"); }catch(e){ data={}; }
      if(!r.ok) throw new Error(data?.error || text || `HTTP ${r.status}`);
    }

    schemaFields = data.fields || data.schema_table || [];
    questions = (data.questions || []).map(q => (typeof q==="string" ? {text:q} : q));
    renderFieldMap(schemaFields);
    show("stepB", true);
    renderQuestions(questions);
    show("stepC", true);
    setMsg("aMsg", `Profiling complete. Detected ${schemaFields.length} fields Â· ${questions.length} questions.`, "ok");
  }catch(e){
    console.error(e);
    setMsg("aMsg", `Profiling failed: ${e.message || "Check logs."}`, "err");
  }finally{
    setBusy(btn,false);
  }
}



async function onGenerateDesign(){
  const btn = $("genDesign");
  setBusy(btn,true,"Designingâ€¦");
  setMsg("cMsg","");
  try{
    const payload = { schema_table: schemaFields, answers: Object.values(answers||{}) };
    const r = await fetch(`${ORCH}/design/${encodeURIComponent(sid)}`, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    const text = await r.text();
    let data={};
    try{ data = JSON.parse(text||"{}"); }catch(e){}
    if(!r.ok) throw new Error(data?.error || text || `HTTP ${r.status}`);
    dsl = data.dsl || data;
    show("stepD", true);
    currentFilters = [];
    localLayout = {};
    // Default to showing all data (no date filter)
    // Users can apply YTD or other date ranges using the filter buttons
    $("filterStart").value = "";
    $("filterEnd").value = "";
    refreshPreview();

    // Add initial AI summary to chat
    clearChatMessages();
    const notes = (dsl && Array.isArray(dsl.__notes)) ? dsl.__notes : null;
    if (notes && notes.length) {
      setMsg("cMsg", "Design created. AI notes: " + notes.join(" Â· "), "ok");
      addChatMessage("Dashboard created! Here's what I've included:\n\nâ€¢ " + notes.join("\nâ€¢ "), false, true);
    } else {
      setMsg("cMsg","Design created.","ok");
      addChatMessage("Dashboard created successfully! You can now ask me to make changes to any chart or add new visualizations.", false, true);
    }

    // Render suggestions carousel
    var sug = (dsl && Array.isArray(dsl.__suggestions)) ? dsl.__suggestions : [];
    renderSuggestions(sug);
    // Show Save Dashboard button
    var saveBtn = $("saveDashboard"); if(saveBtn) saveBtn.style.display = "";
  }catch(e){
    console.error(e);
    setMsg("cMsg","Failed to create design. Check logs.","err");
  }finally{
    setBusy(btn,false);
  }
}

async function onApplyChange(){
  console.log("[Chat] onApplyChange called");
  const btn = $("applyChange");
  const change = ($("changeText").value||"").trim();
  
  if(!change){
    addChatMessage("Please describe the changes you want to make.", false);
    return;
  }
  
  // Add user message to chat
  addChatMessage(change, true);
  
  // Show thinking animation
  addThinkingPlaceholder();
  
  setBusy(btn,true,"Sendingâ€¦");
  
  try{
    // Prepare chat history to send to backend
    const chatHistory = chatMessageHistory.map(msg => ({
      role: msg.isUser ? "user" : "assistant",
      content: msg.text
    }));
    
    // Build current tile state: merge DSL tiles with user's drag/resize positions
    var currentTiles = [];
    if(dsl && dsl.pages && dsl.pages[0] && dsl.pages[0].tiles){
      currentTiles = dsl.pages[0].tiles.map(function(t){
        var pos = localLayout[t.id];
        if(pos){
          return Object.assign({}, t, { x: pos.x, y: pos.y, w: pos.w, h: pos.h });
        }
        return t;
      });
    }

    const r = await fetch(`${ORCH}/edit/${encodeURIComponent(sid)}`, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ 
        change,
        chat_history: chatHistory,
        current_tiles: currentTiles
      })
    });
    const j = await r.json();
    dsl = j.dsl || dsl;

    // Remove thinking animation
    removeThinkingPlaceholder();

    if (j && j.clarify) {
      // AI needs clarification
      addChatMessage("â“ " + j.clarify, false, true); // Animate clarification
      setBusy(btn,false);
      return;
    }

    await refreshPreview();

    // AI response message
    // Use the backend's response if provided, otherwise just confirm success
    let responseText;
    if (j.response) {
      // Backend provided a specific response (which should be contextual based on chat_history)
      responseText = j.response;
    } else {
      // Fallback to simple confirmation
      responseText = "âœ“ Change applied successfully!";
    }
    
    // Animate AI response with typing effect
    addChatMessage(responseText, false, true);

    $("changeText").value = "";
  }catch(e){
    console.error("[Chat] Error:", e);
    removeThinkingPlaceholder();
    addChatMessage("âŒ Sorry, I couldn't apply that change. Please try rephrasing your request.", false, true);
  }finally{
    setBusy(btn,false);
  }
}

async function onSaveLayout(){
  const tiles = (dsl?.pages?.[0]?.tiles||[]).map(t=>{
    const pos = localLayout[t.id] || {x:t.x,y:t.y,w:t.w,h:t.h};
    return {id:t.id, x:pos.x, y:pos.y, w:pos.w, h:pos.h};
  });
  try{
    const r = await fetch(`${ORCH}/edit/${encodeURIComponent(sid)}`, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ tiles })
    });
    const j = await r.json();
    dsl = j.dsl || dsl;
    setMsg("dMsg","Layout saved.","ok");
  }catch(e){
    console.error(e);
    setMsg("dMsg","Layout save failed.","err");
  }
}

function onClearFilters(){
  $("filterStart").value = "";
  $("filterEnd").value = "";
  currentFilters = [];
  _showEmptyDateOverlay(false);
  const fs = $("filterStatus");
  if(fs) { fs.textContent = ""; fs.style.color = "#6b7280"; }
  refreshPreview();
}
function onExportPdf(){ window.print(); }

/* ---------- Remove tile from dashboard ---------- */
async function removeTileFromDashboard(tileId, chartTitle){
  try{
    var r = await fetch(ORCH + "/edit/" + encodeURIComponent(sid), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ remove_tile: tileId })
    });
    var j = await r.json();
    if(j.dsl) dsl = j.dsl;
    // Also remove from local layout
    delete localLayout[tileId];
    await refreshPreview();
    addChatMessage("\u2713 Removed \"" + chartTitle + "\" from the dashboard.", false, true);
  }catch(e){
    console.error("[Remove] failed:", e);
  }
}

/* ---------- Suggestions Carousel ---------- */
var currentSuggestions = [];

function toggleSuggestions(){
  var body = $("suggestionsBody");
  var toggle = $("suggestionsToggle");
  var hint = document.querySelector(".sg-collapse-hint");
  if(!body || !toggle) return;
  var isVisible = !body.classList.contains("hidden");
  body.classList.toggle("hidden", isVisible);
  toggle.classList.toggle("open", !isVisible);
  if(hint) hint.textContent = isVisible ? "click to expand" : "click to collapse";
}

function renderSuggestions(suggestions){
  var panel = $("suggestionsPanel");
  var body = $("suggestionsBody");
  var countEl = $("suggestionsCount");
  if(!panel || !body) return;

  currentSuggestions = (suggestions || []).filter(function(s){ return s && s.title; });
  if(!currentSuggestions.length){
    panel.classList.add("hidden");
    return;
  }

  panel.classList.remove("hidden");
  if(countEl) countEl.textContent = currentSuggestions.length + " available";
  body.innerHTML = "";

  currentSuggestions.forEach(function(sg, idx){
    var card = document.createElement("div");
    card.className = "suggestion-card";

    var previewDiv = document.createElement("div");
    previewDiv.className = "sg-preview";
    previewDiv.id = "sg-preview-" + idx;
    var loadingSpan = document.createElement("span");
    loadingSpan.className = "sg-loading";
    loadingSpan.textContent = "Loading preview\u2026";
    previewDiv.appendChild(loadingSpan);

    var contentDiv = document.createElement("div");
    contentDiv.className = "sg-content";
    var typeEl = document.createElement("div");
    typeEl.className = "sg-type";
    typeEl.textContent = (sg.type || "chart").replace(/_/g, " ");
    var titleEl = document.createElement("div");
    titleEl.className = "sg-title";
    titleEl.textContent = sg.title || "Chart";
    var ratEl = document.createElement("div");
    ratEl.className = "sg-rationale";
    ratEl.textContent = sg.rationale || "";
    contentDiv.appendChild(typeEl);
    contentDiv.appendChild(titleEl);
    contentDiv.appendChild(ratEl);

    var btn = document.createElement("div");
    btn.className = "sg-add-btn";
    btn.textContent = "+ Add to Dashboard";
    btn.dataset.idx = String(idx);
    btn.addEventListener("click", function(){
      addSuggestionToDashboard(parseInt(this.dataset.idx));
    });

    card.appendChild(previewDiv);
    card.appendChild(contentDiv);
    card.appendChild(btn);
    body.appendChild(card);

    fetchSuggestionPreview(sg, idx);
  });
}

async function fetchSuggestionPreview(sg, idx){
  var el = document.getElementById("sg-preview-" + idx);
  if(!el || !sid) return;
  try{
    var tileDef = { id: "sgp_" + idx, type: sg.type || "bar", title: sg.title || "", query: sg.query || {} };
    var r = await fetch(ORCH + "/preview-suggestion/" + encodeURIComponent(sid), {
      method: "POST", headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tile: tileDef })
    });
    var j = await r.json();
    if(j.ok && j.vl_spec && Object.keys(j.vl_spec).length > 0){
      el.innerHTML = "";
      var chartDiv = document.createElement("div");
      chartDiv.style.cssText = "width:100%;height:100%;";
      el.appendChild(chartDiv);
      if(typeof vegaEmbed === "function"){
        var spec = j.vl_spec;
        spec.width = "container"; spec.height = "container";
        spec.autosize = { type: "fit", contains: "padding" };
        spec.config = spec.config || {};
        spec.config.padding = 4;
        spec.config.axis = { labelFontSize: 8, titleFontSize: 9 };
        spec.config.legend = { labelFontSize: 8, titleFontSize: 9 };
        await vegaEmbed(chartDiv, spec, { actions: false, renderer: "svg" });
      }
    } else {
      el.innerHTML = "<span class='sg-loading' style='color:#d1d5db'>No preview</span>";
    }
  }catch(e){
    var el2 = document.getElementById("sg-preview-" + idx);
    if(el2) el2.innerHTML = "<span class='sg-loading' style='color:#d1d5db'>No preview</span>";
  }
}

async function addSuggestionToDashboard(idx){
  if(idx < 0 || idx >= currentSuggestions.length) return;
  var sg = currentSuggestions[idx];
  var btns = document.querySelectorAll(".sg-add-btn");
  var btn = btns[idx];
  if(btn){ btn.textContent = "Adding\u2026"; btn.style.pointerEvents = "none"; }

  var newTile = {
    id: "sg_" + Date.now(),
    type: sg.type || "bar",
    title: sg.title || "New Chart",
    query: sg.query || {},
    w: 6, h: 4
  };

  // Merge with existing tiles (preserve current layout from localLayout)
  var existingTiles = (dsl && dsl.pages && dsl.pages[0] && dsl.pages[0].tiles) ? dsl.pages[0].tiles : [];
  var mergedTiles = existingTiles.map(function(t){
    var stored = localLayout[t.id];
    if(stored){
      return Object.assign({}, t, { x: stored.x, y: stored.y, w: stored.w, h: stored.h });
    }
    return t;
  });
  mergedTiles.push(newTile);

  try{
    var r = await fetch(ORCH + "/edit/" + encodeURIComponent(sid), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tiles: mergedTiles })
    });
    var j = await r.json();
    if(j.dsl) dsl = j.dsl;

    currentSuggestions.splice(idx, 1);
    if(dsl) dsl.__suggestions = currentSuggestions;
    renderSuggestions(currentSuggestions);

    await refreshPreview();
    addChatMessage("\u2713 Added \"" + (sg.title || "chart") + "\" to the dashboard.", false, true);
  }catch(e){
    console.error("[Suggestions] add failed:", e);
    if(btn){ btn.textContent = "+ Add to Dashboard"; btn.style.pointerEvents = ""; }
    addChatMessage("Failed to add chart. Try asking in the chat instead.", false, true);
  }
}

/* ---------- Boot ---------- */
(async () => {
  // Always start fresh - clear any existing session
  cookieDel("mr_sid");
  sid = null;
  
  try {
    await ensureSession();
  } catch(e) {
    console.error(e);
    setMsg("aMsg","Could not create a session. Please reload.","err");
  }
  
  // Watch for chat container being re-added to DOM
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === 1) { // Element node
          // Check if it's the chat messages container or contains it
          let chatMessages = null;
          if (node.id === 'chatMessages') {
            chatMessages = node;
          } else if (node.querySelector) {
            chatMessages = node.querySelector('#chatMessages');
          }
          
          if (chatMessages) {
            // Force max-height and scrolling inline
            chatMessages.style.maxHeight = '400px';
            chatMessages.style.overflowY = 'auto';
            chatMessages.style.minHeight = '120px';
            
            if (chatMessageHistory.length > 0) {
              console.log("[Chat] Detected chat container re-added to DOM, restoring messages...");
              setTimeout(() => restoreChatMessages(), 100);
            }
          }
        }
      });
    });
  });
  
  // Start observing
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  console.log("[Chat] MutationObserver started - will restore messages if container is recreated");
  
  // Ensure chat container has proper styling from the start
  const initialChatMessages = document.getElementById('chatMessages');
  if (initialChatMessages) {
    initialChatMessages.style.maxHeight = '400px';
    initialChatMessages.style.overflowY = 'auto';
    initialChatMessages.style.minHeight = '120px';
    console.log("[Chat] Applied max-height to chat container");
  }
  
  // â”€â”€ Save Dashboard to user account â”€â”€
  async function onSaveDashboard(){
    if(!sid){ alert("No active session."); return; }
    // Check auth
    var me = null;
    try{
      var r = await fetch(ORCH + "/portal-api/me", {credentials:"include"});
      if(r.ok) me = await r.json();
    }catch(e){}
    if(!me || !me.ok){
      // Not logged in â€” go to WordPress login, come back after
      var ret = encodeURIComponent(window.location.href + (window.location.href.includes("?")?"&":"?") + "save_pending=true");
      window.location.href = "https://mranalyticshub.com/log-in/?redirect_to=" + ret;
      return;
    }
    var defaultTitle = (dsl && dsl.__ai_notes && dsl.__ai_notes.title) || "My Dashboard";
    var title = prompt("Name your dashboard:", defaultTitle);
    if(title === null) return;
    var btn = $("saveDashboard"); btn.disabled = true; btn.textContent = "Saving...";
    try{
      var r2 = await fetch(ORCH + "/portal-api/dashboards/save", {
        method:"POST", credentials:"include",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({session_id: sid, title: title || defaultTitle})
      });
      var data = await r2.json();
      if(data.ok){
        btn.textContent = "âœ“ Saved!"; btn.style.background = "#16a34a";
        setTimeout(function(){
          if(confirm("Dashboard saved! Go to your dashboard portal?")){
            window.location.href = ORCH + "/portal";
          } else { btn.textContent = "ðŸ’¾ Save Dashboard"; btn.style.background = "#7c3aed"; btn.disabled = false; }
        }, 500);
      } else { alert("Save failed: " + (data.error||"Unknown error")); btn.textContent = "ðŸ’¾ Save Dashboard"; btn.style.background = "#7c3aed"; btn.disabled = false; }
    }catch(e){ alert("Save failed: " + e.message); btn.textContent = "ðŸ’¾ Save Dashboard"; btn.style.background = "#7c3aed"; btn.disabled = false; }
  }
  // Auto-save if returning from login
  if(new URLSearchParams(window.location.search).get("save_pending")){
    var u = new URL(window.location); u.searchParams.delete("save_pending"); window.history.replaceState({},"",u);
    setTimeout(function(){ if(sid) onSaveDashboard(); }, 1500);
  }

  $("newSession").addEventListener("click", onNewSession, {passive:true});
  $("start").addEventListener("click", onProfile, {passive:true});
  $("genDesign").addEventListener("click", onGenerateDesign, {passive:true});
  $("applyChange").addEventListener("click", onApplyChange, {passive:true});
  $("saveLayout").addEventListener("click", onSaveLayout, {passive:true});
  $("clearFilters").addEventListener("click", onClearFilters, {passive:true});
  $("exportPdf").addEventListener("click", onExportPdf, {passive:true});
  $("saveDashboard").addEventListener("click", onSaveDashboard, {passive:true});
  $("applyFilters").addEventListener("click", ()=>refreshPreview(), {passive:true});
  $("btnYTD").addEventListener("click", ()=>setQuickRange("YTD"), {passive:true});
  $("btnLastYear").addEventListener("click", ()=>setQuickRange("LAST_YEAR"), {passive:true});
  $("btnThisMonth").addEventListener("click", ()=>setQuickRange("THIS_MONTH"), {passive:true});
  $("btnLastMonth").addEventListener("click", ()=>setQuickRange("LAST_MONTH"), {passive:true});
})();
</script>
</body>
</html>